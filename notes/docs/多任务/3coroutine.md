# 协程 Coroutine

协程（又称微线程，纤程），不需要考虑死锁等安全问题，因为它是单线程的，子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，也不存在同时写变量冲突，在协程中控制共享资源不需要锁机制，只需要判断状态就好了

Python对协程的支持是通过generator实现的。在generator中，我们不但可以通过`for`循环来迭代，还可以不断调用`next()`函数获取由`yield`语句返回的下一个值。但是Python的`yield`不但可以返回一个值，它还可以接收调用者发出的参数。

传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过`yield`跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。

用协程代替多线程和多进程是一个很好的选择，因为它吸引人的特性：主动调用/退出，状态保存，避免cpu上下文切换等

- gevent 第三方库，给予了我们一种以同步逻辑来书写异步程序的能力
- asyncio 内置标准库，异步的

## asyncio

Python3.4引入asyncio标准库，直接内置了对异步IO的支持，Python从3.5开始为asyncio提供了async和await的新语法

想用好 Asyncio，特别是发挥其强大的功能，很多情况下必须得有相应的 Python 库支持。比如多线程编程中可以使用requests库发送请求，但协程中需要使用兼容Asyncio的aiohttp库。
