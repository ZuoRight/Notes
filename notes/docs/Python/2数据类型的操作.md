# 数据类型的操作

## 类型检查

检查某个对象是否为已知类型：`isinstance(object, object_type)`，是则返回True，不是则返回False。

- 检测是否为可迭代的、可反转的、可哈希的、迭代器、生成器

```python
from collections.abc import Iterable, Reversible, Hashable, Iterator, Generator

_num = 123
_str = "123"
_tuple = (1,2,3)
_list = [1, 2, [31, 32]]
_set = {1,2,3}
_dict = {"a":1,"b":2,"c":3}


# 数值、字符串、元组等不可变的都是可哈希的
print(isinstance(_num, Hashable))  # True
print(isinstance(_str, Hashable))  # True
print(isinstance(_tuple, Hashable))  # True

print(isinstance(_list, Hashable))  # False
print(isinstance(_set, Hashable))  # False
print(isinstance(_dict, Hashable))  # False


# 除了数值型都是可迭代的
print(isinstance(_str, Iterable))  # True
print(isinstance(_tuple, Iterable))  # True
print(isinstance(_list, Iterable))  # True
print(isinstance(_set, Iterable))  # True
print(isinstance(_dict, Iterable))  # True

print(isinstance(_num, Iterable))  # False


# 序列都是可反转的
print(isinstance(_str, Reversible))  # True
print(isinstance(_tuple, Reversible))  # True
print(isinstance(_list, Reversible))  # True

print(isinstance(_num, Reversible))  # False
print(isinstance(_set, Reversible))  # False
print(isinstance(_dict, Reversible))  # False

# 是否为迭代器
isinstance(x, Iterator)

# 是否为生成器
isinstance(x, Generator)
```

- 可同时检测是否为多种类型中的其中一种

```python
isinstance(object, (int,float))
```

## 可下标类型特有的操作

### 索引

索引，即下标，从0计起。

```python
# 获取索引对应的元素
x[1]

# 获取元素对应的索引，如果有重复元素则返回第一个的索引
x.index(item)
```

### 切片

比循环更简洁

```python
# 从头到尾，相当于浅拷贝
_sub[:]
_sub[x:]  # x~尾
_sub[:y]  # 头~y

# 从x到y，不包含y
_sub[x:y]
_sub[x:y:n]  # 每隔n步取一次，比如取奇数：_sub[1::2]
```

### 反转

```python
# 列表自带方法(原对象改变)
_list.reverse()

# 内置函数reversed()反转，反转后得到一个迭代器(原对象不变)
reversed(x)

# 切片方式反转(原对象不变)
x[::-1]
```

## list

```python
# 列表自带排序方法(原对象会被改变)
_list.sort()
_list.sort(reverse=True)

# 内置函数sorted()排序，元素类型要一致可排，否则报错(原对象不变)
sorted(_list)  # 正序
sorted(_list, reverse=True)  # 倒序
```

## dict

```python
_dict[key]  # key不存在会报错

_dict.get(key, "unkown")  # key不存在，返回None（可以设置其它默认值）

_dict.setdefault(key, value) # key不存在，则将key添加到字典中，值默认为default（也可以设置为其它value），{key:default}

# 以下都不接受参数
_dict.keys()  # dict_keys(['k1', 'k2', 'k3'])
_dict.values()  # dict_values(['v1', 'v2', 'v3'])
_dict.items()  # dict_items([('k1', 'v1'), ('k2', 'v2'), ('k3', 'v3')])
```

python3.7开始dict是有序的

```python
sorted(_dict.items(), key=lambda x:x[0])  # dict按key排：[('a', 3), ('b', 1), ('c', 2)]
sorted(_dict.items(), key=lambda x:x[1])  # dcit按value排：[('b', 1), ('c', 2), ('a', 3)]
```

## 可迭代类型的操作

### 统计

```python
# 序列自带方法，统计某元素出现的次数
_str.count("1")
_tuple.count(1)
_list.count(1)
```

```python
# 统计iterable元素的个数
len(iterable)

# 统计iterable中值最大的
max(iterable)

# 统计iterable中值最小的
min(iterable)
```

### 遍历

- list

```python
for i in _list:
    print(i)
```

- dict

```python
# 遍历键
for k in _dict.keys():  # 也可以不用加.keys()
    print(k)

# 遍历值
for v in _dict.values():
    print(v)

# 遍历键值对
for k, v in _dict.items():
    print('key: {}, value: {}'.format(k, v))
```

## 数据类型的转换

根据不同类型间做运算时会不会自动改变类型，可以分为：

- **弱类型**：会，比如：JS

- **强类型**：不会（报错），比如：Java、Python

强类型语言可以使用函数做类型转换

- 数值型之间互转

```python
int(1.2)  # 1
int(False)  # 0

float(1)  # 1.0
float(True)  # 1.0

bool(0)  # False
bool(1.2)  # True
```

```python
int(x)  # 转成十进制

bin(x)  # 转成二进制
oct(x)  # 转成八进制
hex(x)  # 转成十六进制
```

- `数值型`与`Str`互转

```python
int("123")  # 123
float("123")  # 123.0
bool("123")  # True

str(123)  # "123"
str(1.2)  # "1.2"
str(True)  # "True"
```

- `Str`与`ASCII码`互转

```python
# max()和min()就是据此返回可迭代对象中元素谁大谁小的
chr(77)  # M
ord("a") # 97
```

- `Str`与`Bytes`互转

```python
_str = "中文"
_bytes = b'\xe4\xb8\xad\xe6\x96\x87'

# 编码，str => bytes
_str.encode('utf-8')  # b'\xe4\xb8\xad\xe6\x96\x87'
# 或者
bytes(_str)  # 默认encoding='utf-8'，可以指定其它

# 解码，bytes => str
_bytes.decode()  # 默认解码格式：'utf-8'，可以指定其它
```

- iterable 互转

```python
# iterable如果是字典只取key
_tuple = tuple(iterable)  # ("a", "b", "c")
_list = list(iterable)  # ["a", "b", "c"]
_set = set(iterable)  # {"a", "b", "c"} 会自动去重
_set = frozenset(iterable)  # frozenset({"a", "b", "c"}) 不可重复且不可变

_dict = dict.fromkeys(iterable)  # {'a': None, 'b': None, 'c': None}
_dict = dict.fromkeys(iterable, 10)  # {'a': 10, 'b': 10, 'c': 10}
```

## 数据类型的拼接

```python
# 拼接两个字符串
'a' + 'b'  # 'ab'
"+".join("abc")  # "a+b+c"

# 拼接两个元组
(1,2) + (3,4)  # (1,2,3,4)

# 拼接两个列表
[1,2] + [3,4]  # [1,2,3,4]


# 拼接两个集合
# 参数可以是任意 iterable，如果是字典只会把key拼接到集合中
_set.update(_iter)

# 拼接两个字典
# 参数只能是字典
_dic.update(_dict2)

_dict = {**dict1, **dict2}
```

## 数据类型的复制

- 对于字符串都是引用
- 对于元组，只有深拷贝才不是引用，否则都是引用

以下x为可变数据类型

### 引用

```python
# id(y) == id(x)
# x赋值给y，y只是x的一个引用，会跟着x的改变而改变
y = x
```

### 浅拷贝

- 工厂函数`.copy()`

```python
# id(y) != id(x)
# 只能拷贝父级元素，即改变x的父级元素，y的父级元素不会变
# 子级元素仍为引用，即改变x的子级元素，y的子级元素也会变
y = x.copy()
```

- `copy.copy()`函数

```python
import copy
y = copy.copy(x)
```

- 列表的切片操作也是浅拷贝：`_list[:]`

### 深拷贝

```python
# id(y) != id(x)
# 父级与子级元素都会被拷贝，即改变x任意元素，都不会影响y的元素改变
import copy
y = copy.deepcopy(x)
```
