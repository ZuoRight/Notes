# 模块

**模块**(Module)，即一个`.py`文件（类似其他语言中的库或者组件），一个模块中可以包含多个类（其它语言中一般只能包含一个类）。

**包**(Package)，模块的集合，即带有`__ini__.py`文件的文件夹。

不需要`main`函数，参考：[Python为什么没有main函数？](https://mp.weixin.qq.com/s/1ehySR5NH2v1U8WIlXflEQ)

第三方包

来源：pypi.python.org

下载

安装

管理


## 标准格式

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'''a test module'''

__author__ = '7c'
```

1. 表示文件可以直接在Unix/Linux/Mac上运行
2. 表示文件使用标准UTF-8编码
3. 任何模块代码的第一个字符串都被视为模块的文档注释
4. 标注作者

## 导入

```python
# 一般用于导入内置模块
import xx.xx

# 一般用于导入第三方及自定义模块
from xx.xx import xx

# 导入后重命名，可用于简写模块名，或者避免命名冲突
from xx.xx import xx as rename

# 导入全部，容易发生命名冲突，慎用
# 不过可以在__init__.py模块中创建__all__ = ["module_name"]变量，定义*的范围
from xx.xx import *
```

默认搜索顺序：

1. 自定义模块：当前执行脚本所在目录
2. 内置模块：Python的安装目录
3. 第三方模块：Python安装目录里的site-packages目录

## 类

```python
# 默认继承object父类，可以省略不写
# 可以同时继承多个父类，子类调用父类时，按广度优先算法查找
class Foo(object):
    """关于该类的描述信息"""

    class_x = "类变量，类属性"
    __x = "私有类变量"
```

- 自动执行的方法

```python
    # 实例初始化方法，有些语言也叫构造函数，obj = Foo()时自动执行
    # 至少要有一个self参数，self代表的就是实例化后的实例（类似其它语言中的this）
    # 只能默认返回None，而不能return其它值
    def __init__(self, a, b):
        self.a = a  # 实例变量
        self.__b = b  # 私有实例变量

        # 调用父类方法
        super(Foo, self).__init__()


    # 析构方法，内存中被释放（垃圾回收）时自动执行
    # 无须自定义，但也可以在这里定义一些释放时要做的事
    def __del__(self):
        print("Python自带内存分配和释放机制")
```

- 特殊方式执行的方法

```python
    # obj()带括号时执行
    def __call__(self, *args, **kwargs):
        print('可以用callable(Foo)函数判断是否可执行')


    # print(obj)时执行
    # 如果没定义则返回：<__main__.Foo object at 0x00E90DB0>
    def __str__(self):
        return '打印实例时返回的信息'


    # 通常__repr__与__str__返回值一样，为了调试用的
    __repr__ = __str__
```

- 可定义的方法

```python
    # 取值函数
    # 触发方式：x = 标识符[]
    def __getitem__(self, key):
        print('__getitem__',key)

    # 赋值函数
    # 触发方式：标识符[] = x
    def __setitem__(self, key, value):
        print('__setitem__',key,value)

    # 删除函数
    # 触发方式：del 标识符[]
    def __delitem__(self, key):
        print('__delitem__',key)

    # 使类变为可迭代对象
    # 触发方式：
    # for i in obj:
    #     print(i)
    def __iter__(self):
        yield 1
        yield 2
        yield 3
```

- 自定义方法

```python
    # 实例方法，使用obj.func()方式调用
    def func(self):
        pass

    # 类方法，用类名直接调用
    @classmethod
    def class_method(cls):
        pass

    # 静态方法，无需self或cls参数，可用类名直接调用
    @staticmethod
    def static_method():
        pass
```

- 实例化

```python
# 如果当前模块名(__name__)为xxx则执行
if __name__ == "__main__":
    obj = Foo()  # 自动执行 __init__函数

    obj()  # 自动执行 __call__函数
    
    print(obj)  # 自动执行__str__函数
```

- 获取成员（即属性和方法）

```python
    # 列出类中的所有成员
    print(Foo.__dict__)

    """
    {
    '__module__': '__main__',

    'class_x': '类变量，类属性',
    '_Foo__x': '私有类变量'
    '__doc__': '注释',

    '__init__': <function Foo.__init__ at 0x009394F8>,
    '__dict__': <attribute '__dict__' of 'Foo' objects>,
    '__weakref__': <attribute '__weakref__' of 'Foo' objects>,

    'func': <function Foo.func at 0x00939588>,
    }
    """

    # 列出对象中的所有成员
    print(obj.__dict__)

    """
    {'a': 'a', '_Foo__b': 'b'}
    """

    # 返回当前操作的对象在属于哪个模块
    print(obj.__module__)  # __main__

    # 返回当前操作的对象属于哪个类
    print(obj.__class__)  # <class '__main__.Foo'>

    # 返回类/模块的描述类信息
    print(Foo.__doc__)
```

- 使用属性

```python
    # 访问类变量
    print(Foo.class_x)

    # 访问实例变量
    print(obj.a)

    # 访问私有类变量
    print(Foo._Foo__x)
    # 或者
    print(obj._Foo__x)

    # 访问私有实例变量
    print(obj._Foo__b)
```

- 使用方法

```python
    Foo.class_method()  # 调用类方法

    Foo.static_method()  # 调用静态方法

    obj.func()  # 调用实例方法
```