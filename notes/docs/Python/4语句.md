# 语句

## 判断语句

- if

```python
if condition:
    expression
[elif] condition:
    expression
[else]:
    expression
```

Python中没有`switch...case...`语句，但可以用字典来实现

<https://www.liujiangblog.com/blog/2/>

```python
def switch(key):
    case = {
        1: "1",
        2: "2",
        3: "3"
    }

    v = case.get(key, "0")
    return v

switch(1)  # "1"
switch(8)  # "0"
```

```python
if x > y:
    res = x
else:
    res = y

# 不换行
if x > y: res = x
else: res = y

# 三元表达式
res = x if x > y else y
res = 1 if 0 else 2 if False else 3  # 3
```

## 循环语句

循环过程中如果改变了对象长度，则可能会影响循环次数，比如循环一个长度为2列表：`for i in _list`，第一次循环中移除了一个元素，此时列表长度变为1，则不会进入下一次循环

这时候可以这样去循环：`for i in list(_list)`

- for

> 常用于循环次数限定的时候
>
> 嵌套循环，外层主要用于循环次数，内层用于遍历

```python
for item in iterable:
    expression
# 正常结束循环时，else子句执行
else:
    expression
```

- while

> 常用于循环次数限定的时候

```python
while condition:
    expression
# while也可以接else
else:
    expression
```

## try语句

```python
try:
    pass  # 可能会出错的地方
except Xxx1Error as e1:
    print(e1)
except Xxx2Error as e2:
    print(e2)
except (Xxx3Error,Xxx4Error) as es:
    print("可以同时捕获多个异常")
except Exception as e:
    print('通用异常，可匹配任意异常')
except:
    print("如果不写异常名称，将匹配所有异常")
else:
    print("如果没有异常则执行")
finally:
    print("不管有没有异常最后都会执行")
```

## with 语句

上下文管理器（Context Manager）是指在一段代码执行之前执行一段代码，用于一些预处理工作。执行之后再执行一段代码，用于一些清理工作。

比如打开文件进行读写，读写完之后需要将文件关闭。又比如在数据库操作中，操作之前需要连接数据库，操作之后需要关闭数据库。

上下文管理器之所以能够实现上述两个功能，是因为定义了上下文管理协议中的两个方法：`__enter__`和`__exit__`。

```python
# 自定义打开文件操作的上下文管理器
class MyOpen(object):
    def __init__(self, file_name):
        """初始化方法"""
        self.file_name = file_name
        self.file_handler = None
        return

    def __enter__(self):
        """enter方法，返回file_handler"""
        print("enter:", self.file_name)
        self.file_handler = open(self.file_name, "r")
        return self.file_handler

    def __exit__(self, exc_type, exc_val, exc_tb):
        """exit方法，关闭文件并返回True"""
        print("exit:", exc_type, exc_val, exc_tb)
        if self.file_handler:
            self.file_handler.close()
        return True

# 另外还可以使用装饰器实现上下文管理器
@contextlib.contextmanager
def open_func(file_name):
    # yield前为__enter__方法
    print('open file:', file_name, 'in __enter__')
    file_handler = open(file_name, 'r')

    yield file_handler

    # yield后为__exit__方法
    print('close file:', file_name, 'in __exit__')
    file_handler.close()
    return
```

- 使用with语句即可调用上下文管理器

```python
with MyOpen("python_base.py") as file_in:
    """
    1. 执行语句，获取上下文管理器
    2. 调用上下文管理器中的__enter__方法，该方法执行一些预处理工作
    3. 将__enter__方法的返回值赋值给file_in，也可以不赋
    4. 执行以下代码块，file_in可以被当作普通变量使用
    """
    for line in file_in:
        print(line)
        raise ZeroDivisionError
    """
    5. 调用上下文管理器中的的__exit__方法
        __exit__方法有三个参数：exc_type, exc_val, exc_tb。
            如果上面代码块发生异常并退出，那么分别对应异常的type、value 和 traceback。
            否则三个参数全为None。
        __exit__方法的返回值可以为True或者False
            如果为True，那么表示异常被忽视，相当于进行了try-except操作（此示例正是这种情况）
            如果为False，则该异常会被抛出
    """
```

- 可以嵌套

```python
with A() as a, B() as b:
    SUITE

# 等价于

with A() as a:
    with B() as b:
        SUITE
```

## 简单语句

### raise 抛出异常

### assert 断言

```python
assert n != 0, "n is zero"  # n如果等于0则抛出次错误提示

assert A and B and C  # 会从做到有断言，只要断言失败，就不会再继续向右继续断言
# 但是更建议分开写
```

### continue

结束当前这次循环，继续执行下一次循环

- break

结束当前整个循环，但只能结束当前层循环

如果想结束所有循环（类似c语言中的goto语句），可以在最外层设置一个flag，让内部控制

### pass

用于占位

```python
# 设置一个flag，默认为False
flag = False
for i in range(10):
    # 跳出外部循环
    if flag:
        break

    for j in range(10):
        if j==7:
            flag = True
            # 跳出内部循环
            break
        print(i,j)
```
