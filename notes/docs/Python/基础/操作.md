## 类型判断

- `type(x)`

```python
# 常用于判断某个未知对象的类型是什么
type(123)  # <class 'int'>
type(1.2)  # <class 'float'>
type(1 + 2j)  # <class 'complex'>
type(None)  # <class 'NoneType'>
type(_str)  # <class 'str'>
type(_tuple)  # <class 'tuple'>
type(_list)  # <class 'list'>
type(_set)  # <class 'set'>
type(_dict)  # <class 'dict'>
```

- `isinstance(object, object_type)`

```python
# 常用于判断某个对象是否为已知类型
# 比如判断对象x是否为可迭代的
from collections.abc import Iterable
isinstance(x, Iterable)
```

## 类型转换

根据不同类型间做运算时会不会自动改变类型，可以分为：

- **弱类型**：会，比如：JS

- **强类型**：不会（报错），比如：Java、Python

强类型语言可以使用函数做类型转换

### 数值型之间互转

```python
int(1.2)  # 1
int(False)  # 0

float(1)  # 1.0
float(True)  # 1.0

bool(0)  # False
bool(1.2)  # True
```

```python
int(x)  # 转成十进制

bin(x)  # 转成二进制
oct(x)  # 转成八进制
hex(x)  # 转成十六进制
```

### `数值型`与`Str`互转

```python
int("123")  # 123
float("123")  # 123.0
bool("123")  # True

str(123)  # "123"
str(1.2)  # "1.2"
str(True)  # "True"
```

### `Str`与`ASCII码`互转

```python
# max()和min()就是据此返回可迭代对象中元素谁大谁小的
chr(77)  # M
ord("a") # 97
```

### `Str`与`Bytes`互转

```python
_str = "中文"
_bytes = b'\xe4\xb8\xad\xe6\x96\x87'

# 编码，str => bytes
_str.encode('utf-8')  # b'\xe4\xb8\xad\xe6\x96\x87'
# 或者
bytes(_str)  # 默认encoding='utf-8'，可以指定其它

# 解码，bytes => str
_bytes.decode()  # 默认解码格式：'utf-8'，可以指定其它
```

### iterable 互转

```python
# iterable如果是字典只取key
_tuple = tuple(_iter)  # ("a", "b", "c")

_list = list(_iter)  # ["a", "b", "c"]

_set = set(_iter)  # {"a", "b", "c"} 会自动去重

_dict = dict.fromkeys(_iter)  # {'a': None, 'b': None, 'c': None}
_dict = dict.fromkeys(_iter, 10)  # {'a': 10, 'b': 10, 'c': 10}
```

## 拼接

```python
# 拼接两个字符串
'a' + 'b'  # 'ab'
"+".join("abc")  # "a+b+c"

# 拼接两个元组
(1,2) + (3,4)  # (1,2,3,4)

# 拼接两个列表
[1,2] + [3,4]  # [1,2,3,4]


# 拼接两个集合
# 参数可以是任意 iterable，如果是字典只会把key拼接到集合中
_set.update(_iter)

# 拼接两个字典
# 参数只能是字典
_dic.update(_dict2)
```

## 复制

- 对于字符串都是引用
- 对于元组，只有深拷贝才不是引用，否则都是引用

以下x为可变数据类型

### 引用

```python
# id(y) == id(x)
# x赋值给y，y只是x的一个引用，会跟着x的改变而改变
y = x
```

### 浅拷贝

- 工厂函数`.copy()`

```python
# id(y) != id(x)
# 只能拷贝父级元素，即改变x的父级元素，y的父级元素不会变
# 子级元素仍为引用，即改变x的子级元素，y的子级元素也会变
y = x.copy()
```

- `copy.copy()`函数

```python
import copy
y = copy.copy(x)
```

- 列表的切片操作也是浅拷贝：`_list[:]`

### 深拷贝

```python
# id(y) != id(x)
# 父级与子级元素都会被拷贝，即改变x任意元素，都不会影响y的元素改变
import copy
y = copy.deepcopy(x)
```

## 统计

```python
# 统计iterable元素的个数
len(_iter)

# 统计iterable中值最大的
max(_iter)

# 统计iterable中值最小的
min(_iter)

# 统计str/tuple/list中某元素出现的次数
_tuple.count(x)
_list.count(x)
```