# 环境搭建

Python，于1991年发行了第一个正式版本，比Java还要早5年，目前在编程语言排行榜中已经稳居前三。由荷兰人[吉多·范罗苏姆 (Guido van Rossum)](https://gvanrossum.github.io)所创建。

## 安装

> 参考：<https://docs.python.org/zh-cn/3.9/using/index.html>

- PC：直接去官网下载安装最新稳定版即可
- Mac

自带了V2.7版本，路径：`/usr/bin/python`，建议不要随便卸载。

不推荐官网下载。（卸载起来比较麻烦）

建议使用`brew install python`安装，安装路径：`/usr/local/cellar/python`），升级与卸载都很方便。

- Ubuntu 16.10+

```bash
sudo apt-get update
sudo apt-get install python3.8
```

- CentOS 7+

```bash
# 官方源没有，得用epel源
sudo yum install epel-release
# 不一定包含最新版Python
yum search python
# 安装3.7，不包含pip
sudo yum install python37
# 安装setuptools，与Python版本保持一致
yum install python37-setuptools
# 安装pip
easy_install pip
```

- Docker

> 参考：<https://hub.docker.com/_/python>

```bash
sudo docker run -dit --name demo python:3.9 "/bin/bash"
sudo docker exec -it demo "/bin/bash"
```

```bash
FROM python:3.9

# ENV PYTHONUNBUFFERED=1
'''
不缓冲stdin、stdout和stderr，默认是缓冲的
相当于设置 python 命令行的 -u 选项
'''

WORKDIR /usr/src/app
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

# CMD ["python", "manage.py", "runserver"]
```

## 环境

[普通命令行](https://docs.python.org/3.9/using/cmdline.html#command-line-and-environment)

### 交互式命令行

- Python Shell
- [IPython](https://ipython.org/)

Python Shell 是自带命令行工具，常用于验证一些代码片段，而 IPython 是基于 Python Shell 的第三方开源交互命令行，更强大，它其实是Jupyter的内核。

`pip install ipython`

### IDE

- IDLE
- [PyCharm](https://www.jetbrains.com/pycharm/)
- VSCode

IDLE是自带的简易集成开发和学习环境

PyCharm是由位于捷克的[JetBrains公司](https://www.jetbrains.com/)为Python语言所生产的商业IDE，具体使用方法可参考：[PyCharm 中文指南](http://pycharm.iswbm.com/zh_CN/latest/)

VSCode并不算IDE，只是一个编辑器，个人比较喜欢用这个开发Python，而不是更智能的PyCharm，因为我觉得它过于傻瓜化，用习惯后会影响我的开发能力。

### 包管理工具有以下几种选择

> 多版本依赖包管理用自带的venv足矣，多版本Python管理用pyenv（不支持win）

- pip + venv
- pip + virtualenv + virtualenvwrapper
- pipenv
- conda

## pip

官方文档：<https://pip.pypa.io/en/stable/cli/>

```bash
# 查看所有命令参数
pip

# 查看已安装的包
pip list
# 查看过期的包
pip list -o

# 查看某个库的具体信息(版本号、依赖、位置等)
pip show xxx
# 查询更加具体的信息
pip show -f xxx
```

```bash
# 搜索包
pip search xxx
# 下载包
pip download xxx

# 安装，默认安装最新版本
pip install xxx
# 指定版本
pip install xxx==version
# 指定镜像源
pip install xxx -i 镜像源 --trusted-host 镜像地址对应的host

# 更新包，也可以更新pip自己
pip install -U xxx

# 卸载包
pip uninstall xxx
# 卸载pip本身
pip -m pip uninstall pip
```

```bash
# 查看已安装的包
pip freeze
# 将环境中所有已安装的库及其版本导出到指定文件
pip freeze > requirements.txt
# 安装指定文件中列出的所有库
pip install -r requirements.txt
# 卸载指定文件中列出的所有库
pip uninstall -r requirements.txt
```

设置镜像（阿里云）：`~/.pip/pip.conf`

```conf
[global]
index-url = https://mirrors.aliyun.com/pypi/simple/

[install]
trusted-host=mirrors.aliyun.com
```

## venv

```bash
# 在当前目录创建一个名为env(可自定义)的虚拟环境，删除它即删除了虚拟环境
python3 -m venv env

# 激活虚拟环境，激活后命令提示符前会显示：(env)
source env/bin/activate  # Mac/Linux
env\Scripts\activate  # Windows

# 安装项目依赖
pip install -r requirements.txt

# 退出虚拟环境
deactivate
```

---

> 用来用去还是更喜欢Python自带的Pip+Venv，以下工具仅仅是以前使用过的记录，不推荐

## pipenv

由requests库的作者Kenneth Reitz基于pip和virtualenv所编写

> 参考：<https://www.liujiangblog.com/blog/18/>

- Windows：`pip install pipenv`
- Mac：`brew install pipenv`

命令格式：`pipenv [options] command [args]`

### 初始化项目

如果是新项目，可以先用`pipenv --python 3`初始化(可指定具体版本)一个虚拟环境，查看当前环境所在路径：`pipenv --venv`，一般默认路径为：

- Windows：`~\.virtualenvs\`
- Mac：`~/.local/share/virtualenvs/`

> 删除虚拟环境：`pipenv --rm`

项目路径下会生成一个TOML格式的Pipfile文件，内容如下：

```TOML
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]

[dev-packages]

[requires]
python_version = "3.7"
```

其中url字段为官方下载源，比较慢，建议替换为国内镜像源，比如：`https://mirrors.aliyun.com/pypi/simple/`。

### 安装项目依赖

`packages`和`dev-packages`节点下列出了生产和开发环境所需的依赖，可以使用`pipenv install [--dev]`一键安装

> tips：如果没有初始化项目(或者说没有Pipfile文件)，直接执行`pipenv install [--two/three]会自动初始化并生成Pipfile。

```bash
pipenv install -r requirements.txt  # 从requirements.txt中安装
pipenv install xxx  # 安装
pipenv uninstall xxx  # 卸载

pipenv venv  # 查看当前环境路径
pipenv graph  # 查看依赖关系及信息
pipenv update  # 更新所有依赖
```

安装完依赖后会自动生成一个JSON格式的`Pipfile.lock`文件，保存着所有依赖的版本和hash信息（默认使用sha256算法给每一个包进行hash，可以保证在不安全的网络环境下也能下载到正确的包），每次更新或卸载依赖包都会更新此文件，即lock，类似于当前环境的一个快照，不要手动修改其内容。也可以手动lock：`pipenv lock`。

- 生成依赖列表（为了迁移回venv）：`pipenv lock -r`

### 运行项目

`pipenv run python xxx.py`

如果python命令比较长，可以在Pipfile中添加`[scripts]`节点，然后创建一个别名，比如：

`alias = "python3 manage.py runserver 0.0.0.0:8000"`

然后执行`pipenv run alias`即可

当然还可以`pipenv shell`进入到虚拟环境中执行，退出：`exit`

## virtualenv + virtualenvwrapper

`pip install virtualenv`

除非还使用Python2.x版本，否则使用自带的venv即可

```bash
virtualenv xxx  # 创建
rm -rf xxx  # 删除，或者手动删除对应文件夹

activate.bat  # 进入
deactivate.bat  # 退出
```

为了便于对虚拟环境集中管理，可搭配虚拟环境管理器virtualenvwrapper使用

`pip install virtualenvwrapper-win`

```bash
mkvirtualenv xxx  # 创建
rmvirtualenv xxx  # 删除
workon  # 查看

workon xxx  # 进入
deactivate.bat  # 退出
```

## Conda

> Python常被用于数据的处理，需要基于大量的第三方库，一个个手动安装这些库很麻烦，可以下载已经集成了这些库的发行版Python，比如Anaconda
>
> 下载安装：<https://www.anaconda.com/download/>
>
> Anaconda自带工具Conda，也可以独立使用

虽然Conda来自Python社区且由Python语言开发，但它不止可以管理Python语言及Python的包，还可以管理其他语言的包（Java，R，Ruby，JS，Lua，Scala，C/C++，Fortran）

```bash
conda create -n xxx python=3  # 创建
conda remove -n xxx --all  # 删除
conda info --envs  # 查看

activate xxx  # 进入
deactivate xxx  # 退出
```

## Python之禅

- 简单：类似自然语言
- 明确：做任何事情应有且最好只有一个方法，少即是多。
- 优雅：准确的来说应该是实用

```bash
>>> import this

The Zen of Python, by Tim Peters
# Python 之禅，作者：Tim Peters

Beautiful is better than ugly.
# 优雅胜于丑陋
Explicit is better than implicit.
# 明确胜于晦涩
Simple is better than complex.
# 简洁胜于复杂
Complex is better than complicated.
# 复杂胜于凌乱
Flat is better than nested.
# 扁平胜于嵌套
Sparse is better than dense.
# 间隔胜于紧凑
Readability counts.
# 可读性很重要
Special cases are not special enough to break the rules.
Although practicality beats purity.
# 即便假借特例的实用性之名，也不可违背这些规则
Errors should never pass silently.
Unless explicitly silenced.
# 不要包容所有错误，除非你确定需要这样做
In the face of ambiguity, refuse the temptation to guess.
# 当存在多种可能，不要尝试去猜测
There should be one-- and preferably only one --obvious way to do it.
# 而是尽量找一种，最好是唯一一种明显的解决方案
Although that way may not be obvious at first unless you are Dutch.
# 虽然这并不容易，因为你不是荷兰人（即 Guido）
Now is better than never.
Although never is often better than *right* now.
# 做也许好过不做，但不假思索就动手还不如不做
If the implementation is hard to explain, it^s a bad idea.
If the implementation is easy to explain, it may be a good idea.
# 如果你无法向人描述你的方案，那肯定不是一个好方案，反之亦然
Namespaces are one honking great idea -- lets do more of those!
# 命名空间是一种绝妙的理念，我们应当多加利用
```
