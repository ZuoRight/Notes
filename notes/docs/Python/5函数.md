# 函数

```python
# 关键字def用于声明函数
# 函数在被调用前都是不存在的
def func_name(param1, param2):
    pass

    # 返回值
    # 可以参略，省略则默认返回None
    # 也同时返回多个，多个则以元组形式返回
    return param1, param2

# 调用函数
func(1,2)
```

## 参数类型

首先要区分形参和实参，形参就是定义函数时候的参数，实参是调用函数时传入的参数。

```python
# x,y,z都是形参
def f1(x,y,z):
    pass
    # 参数可以传递给内部函数
    def f2(x):
        pass

# 1,2,3是实参
func(1,2,3)
```

形参可分为固定的和动态的两种。

### 固定参数

固定形参的位置/顺序和个数都是确定的，必须要一对一的传入实参，所以也被叫做位置/顺序/必传参数。

```python
# x,y,z都是固定的
def func(x,y,z):
    pass

# 实参与形参的位置和个数都要一一对应
func(1,2,3)
# 如果以关键字方式传入，位置可以随意
func(y=2,z=3,x=1)
```

```python
# 可以给固定参数设置默认值
# 必须要位于没有默认值参数的后面
# 如果有多个时，建议将不易变的置后
# 且建议不要设置可变的默认值
def func(x,y,z=3):
    pass

# 设了默认值的形参，可不传入实参
func(1,2)
# 设了默认值的形参，可传入其它实参覆盖默认值
func(1,2,8)
```

```python
# 可以让固定参数强制以关键字的方式传入，前面加一个*,
def func(x,y,*,z=3):
    pass

# 必须以关键字的方式给参数z传值
func(1,2,z=8)
```

### 动态参数

动态参数的个数是不固定的，位置也随个数的变化而不确定。

有两种接受实参的形式：

#### `*args`

```python
# 以tuple的形式接受实参
def func(*args):
    pass

# 可以传入任意个数的实参，会被以元组的形式传入
func(1,2,3)  # args=(1,2,3)

# 还可以通过解包的方式传入任意可迭代对象
_str="123"  # args=('1', '2', '3')
_tuple=(1,2,3)  # args=(1, 2, 3)
_list=[1,2,3]  # args=(1, 2, 3)
_set={1,2,3}  # args=(1, 2, 3)
_dict={"a":1, "b":2, "c":3}  # args=('a', 'b', 'c')

func(*X)
```

#### `*kwargs`

```python
# 以dict的形式接受实参
def func(**kwargs):
    pass

# 可以用关键字的方式传入
func(a=1,b=2,c=3)  # kwargs={'a': 1, 'b': 2, 'c': 3}

# 还可以通过解包字典的方式传入
_dict={"a":1, "b":2, "c":3}
func(**_dict)  # kwargs={'a': 1, 'b': 2, 'c': 3}
```

### 参数混合使用

动态参数必须要在固定参数后面

```python
# *args后的固定参数，都被视作关键字参数，且可以省略*号
def func(x,*args,z=0):
    pass

func(1,2,3,4,z=8)
```

```python
# **kwargs必须在*args后面
# **kwargs之后不允许再设置任何参数
def func(x,*args,**kwargs):
    return x, args, kwargs

func(1,2,3)  # (1, (2, 3), {})
func(1,2,3,a=4,b=5)  # (1, (2, 3), {'a': 4, 'b': 5})
```

### 参数的多态性

由于Python函数的参数没有类型限制，所实际使用中可能会带来一些问题，所以必要时建议在函数开头加上数据类型检查

```python
def func():
    if not isinstance(args, args_type):
        pass
        return
    pass
```

## 作用域

### 局部变量

函数内定义的变量默认都是局部变量，在函数外部无法访问函数内部变量和函数

```python
# 全局变量
a = 1

def f1():
    # 局部变量
    a = 2  # 可以和全局变量名字相同，但不建议这样

print(a)  # 1，全局变量没有被重新赋值
```

### 全局变量

函数内部可以访问全局变量

```python
a = 1

def f1():
    print(a)  # a=1
    x = a
    return x  # x=1
```

但函数内无法对全局变量重新赋值

```python
# 全局变量
a = 1
b = {}

def f1():
    a = a + 1  # 定义局部变量a，"a" is unbound，然后+1赋值给自己，这样是有语法错误的

# 函数参数的传递是赋值传递，即形参copy了实参的值，并不会改变指向实参的变量
def f2(a):
    a = a + 1  # 定义局部变量a，形参a+1，赋值给局部变量a，没问题

def f3():
    b["k1"] = "v1"  # dict是可变的，增加元素不算重新赋值
```

函数内如果想改变全局变量，需要使用`global`关键字

```python
# 全局变量
a = 1

def f1():
    global a  # 这里声明了a是全局变量a
    a = a + 1  # 这样就没问题了
```

嵌套的内层函数如果想改变外层函数的变量，需要使用`nonlocal`关键字

```python
# 全局变量
a = 1

def f1():
    # 局部变量
    a = 2

    def f2():
        nonlocal a  # 这里声明了a是外层函数a，即局部变量a
        a = a + 1

    r = f2()
    return r  # a=3
```

## 注释

可以给函数加一些元信息作为注释，易于理解阅读

```python
# 以下示例冒号表示建议传输int类型的变量，箭头表示正常情况应该返回int值
def func(x:int, y:int) -> int:
    return x + y
```

## 核心概念

在Python中，函数是一等公民，即函数也是对象。

### 函数可以被赋值给一个变量

```python
def f1(x):
    print(x)
    
r = f1
r('hello world')
```

### 函数内可以嵌套函数

嵌套函数的使用，能保证数据的隐私性（不能被外界直接调用），提高程序运行效率。

```python
# 外层函数
def print_msg():
    msg = "zen of python"

    # 嵌套函数
    def printer():
        print(msg)

    printer()  # 调用内部函数

another = print_msg()  # 直接输出msg
```

### 函数的返回值可以是函数，即闭包

函数A返回其嵌套的函数B，函数B引用了函数A的属性（变量），相当于返回了函数A的属性，即外部可以以此方式访问到函数内部变量。

调用时，有点像类的实例化。

如果类只有一个方法时，可以考虑使用闭包替代。

可以简化程序的复杂度，提高可读性。

```python
# 外层函数
def print_msg():
    msg = "zen of python"

    # 嵌套函数
    def printer():
        print(msg)

    return printer  # 函数名可以被赋值给变量，可以作为参数被返回

# 有点像类的实例化
another = print_msg()  # 相当于将printer函数赋值给了一个变量，another = printer
another()  # 利用变量调用函数
```

## 匿名函数(lambda表达式)

`f = lambda 输入 : 输出`

```python
(lambda x:x+1)(2)  # 3

# 等价于
def f(x):
    return x+1

f(2)
```

## 函数式编程

> 参考：[函数式编程初探·廖雪峰](http://www.ruanyifeng.com/blog/2012/04/functional_programming.html)

函数式编程是一种抽象程度很高的编程范式（如何编写程序的方法论），属于"结构化编程"的一种。

纯粹的函数式编程语言编写的函数是没有变量的，而Python允许使用变量，所以Python不是纯函数式编程语言，只是部分支持。

特点：

- 函数是一等公民
- 只使用表达式，不使用语句：主要是为了处理运算，而不是数据读写。
- 没有副作用：不能修改外部变量的值。
- 不修改状态：状态由变量存储，不修改状态即不修改变量。
- 引用透明：函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数。即一个函数只要输入是确定的，输出就是确定的。

### map()

用法：将可迭代对象中的每个元素，都作为参数传入函数执行，最后返回一个新的可迭代对象。

`map(f, Iterable)`

```python
_list = [1,2,3]

def f(x):
    return x**2

r = map(f, _list)
print(r)  # <map object at 0x032A0DD0>
print(list(r))  # [1, 4, 9]
```

### filter()

`filter(f, Iterable)`

用法：可迭代对象中的每个元素，经过函数判断，返回True或False，最后将返回True的元素组成一个新的可迭代对象。

```python
_list = [1, 2, 3, 4, 5]

def f(x):
    return x % 2 == 0

r = filter(f, _list)
print(r)
print(list(r))
```

### reduce()

`reduce(f, Iterable)`

用法：将一个集合传入函数做一些累积操作。

```python
# 需要先引入
from functools import reduce

# 集合的元素个数没有要求，可以是1个
_str = "123"  # "1234"
_list = [1,2,3]  # 6
_tupe = (1,2,3)  # 6
_set = {1,2,3}  # 6
_dict = {"a":1, "b":2}  # "ab"

# 函数有且只能有两个参数，一般使用lambda函数最为简洁
def f(x, y):
    return x+y

r = reduce(f, _list)
print(r)
```

## 装饰器

参考：[Python核心技术与实战-强大的装饰器（极客时间）](https://time.geekbang.org/column/article/100914?utm_source=infoq&utm_medium=sitenavigation)

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print('wrapper of decorator')
        func(*args, **kwargs)
    return wrapper

@my_decoratordef
def greet(message):
    print(message)
```

除了函数装饰器，类也有装饰器。