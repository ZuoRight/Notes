# 函数

```python
# 关键字def用于声明函数
# 函数在被调用前都是不存在的
def func_name(param1, param2):
    pass

    # 返回值
    # 可以参略，省略则默认返回None
    # 也同时返回多个，多个则以元组形式返回
    return param1, param2

# 调用函数
func(1,2)
```

## 参数类型

首先要区分形参和实参，形参就是定义函数时候的参数，实参是调用函数时传入的参数。

```python
# x,y,z是形参
def func(x,y,z):
    pass

# 1,2,3是实参
func(1,2,3)
```

形参可分为固定的和动态的两种。

### 固定参数

固定形参的位置/顺序和个数都是确定的，必须要一对一的传入实参，所以也被叫做位置/顺序/必传参数。

```python
# x,y,z都是固定的
def func(x,y,z):
    pass

# 实参与形参的位置和个数都要一一对应
func(1,2,3)
# 如果以关键字方式传入，位置可以随意
func(y=2,z=3,x=1)
```

```python
# 可以给固定参数设置默认值
# 必须要位于没有默认值参数的后面
# 如果有多个时，建议将不易变的置后
# 且建议不要设置可变的默认值
def func(x,y,z=3):
    pass

# 设了默认值的形参，可不传入实参
func(1,2)
# 设了默认值的形参，可传入其它实参覆盖默认值
func(1,2,8)
```

```python
# 可以让固定参数强制以关键字的方式传入，前面加一个*,
def func(x,y,*,z=3):
    pass

# 必须以关键字的方式给参数z传值
func(1,2,z=8)
```

### 动态参数

动态参数的个数是不固定的，位置也随个数的变化而不确定。

有两种接受实参的形式：

#### `*args`

```python
# 以tuple的形式接受实参
def func(*args):
    pass

# 可以传入任意个数的实参，会被以元组的形式传入
func(1,2,3)  # args=(1,2,3)

# 还可以通过解包的方式传入任意可迭代对象
_str="123"  # args=('1', '2', '3')
_tuple=(1,2,3)  # args=(1, 2, 3)
_list=[1,2,3]  # args=(1, 2, 3)
_set={1,2,3}  # args=(1, 2, 3)
_dict={"a":1, "b":2, "c":3}  # args=('a', 'b', 'c')

func(*X)
```

#### `*kwargs`

```python
# 以dict的形式接受实参
def func(**kwargs):
    pass

# 可以用关键字的方式传入
func(a=1,b=2,c=3)  # kwargs={'a': 1, 'b': 2, 'c': 3}

# 还可以通过解包字典的方式传入
_dict={"a":1, "b":2, "c":3}
func(**_dict)  # kwargs={'a': 1, 'b': 2, 'c': 3}
```

### 参数混合使用

动态参数必须要在固定参数后面

```python
# *args后的固定参数，都被视作关键字参数，且可以省略*号
def func(x,*args,z=0):
    pass

func(1,2,3,4,z=8)
```

```python
# **kwargs必须在*args后面
# **kwargs之后不允许再设置任何参数
def func(x,*args,**kwargs):
    return x, args, kwargs

func(1,2,3)  # (1, (2, 3), {})
func(1,2,3,a=4,b=5)  # (1, (2, 3), {'a': 4, 'b': 5})
```

### 参数的多态性

由于Python函数的参数没有类型限制，所实际使用中可能会带来一些问题，所以必要时建议在函数开头加上数据类型检查

```python
def func():
    if not isinstance(args, args_type):
        pass
        return
    pass
```

## 作用域

### 局部变量

函数内定义的变量默认都是局部变量，在函数外部无法访问函数内部变量和函数

```python
# 全局变量
a = 1

def f1():
    # 局部变量
    a = 2  # 可以和全局变量名字相同，但不建议这样

print(a)  # 1，全局变量没有被重新赋值
```

### 全局变量

函数内部可以访问全局变量

```python
# 全局变量
a = 1

def f1():
    print(a)  # a=1
    x = a
    return x  # x=1
```

但函数内无法对全局变量重新赋值

```python
# 全局变量
a = 1
b = {}

def f1():
    a = a + 1  # 试图对全局变量a赋新的值，但这样是有语法错误的
    b["k1"] = "v1"  # 这样是没有错误的，因为并不属于对全剧变量b赋新值

def f2(a):
    a = a + 1  # 声明一个全局变量a，其值等于全局变量a+1
    # 打印局变量a
    print(a)  # 2

f2(a)  # 把全局变量a传递给形参a
# 打印全局变量a
print(a)  # 1，并没有被重新赋值
```

函数内如果想改变全局变量，需要使用`global`关键字

```python
# 全局变量
a = 1

def f1():
    global a  # 这里声明了a是全局变量a
    a = a + 1  # 这样就没问题了
```

嵌套的内层函数如果想改变外层函数的变量，需要使用`nonlocal`关键字

```python
# 全局变量
a = 1

def f1():
    # 局部变量
    a = 2

    def f2():
        nonlocal a  # 这里声明了a是外层函数a，即局部变量a
        a = a + 1

    r = f2()
    return r  # a=3
```

## 注释

可以给函数加一些元信息作为注释，易于理解阅读

```python
# 以下示例冒号表示建议传输int类型的变量，箭头表示正常情况应该返回int值
def func(x:int, y:int) -> int:
    return x + y
```

## 嵌套函数

定义在函数内部的函数，称之为嵌套函数，不能被外界直接调用

嵌套函数的使用，能保证数据的隐私性，提高程序运行效率；

```python
# 外层函数
def print_msg():
    msg = "zen of python"

    # 嵌套函数
    def printer():
        print(msg)

    printer()  # 调用内部函数

another = print_msg()  # 直接输出msg
```

## 闭包

函数A返回其嵌套的函数B，函数B引用了函数A的属性（变量），相当于返回了函数A的属性，即外部可以以此方式访问到函数内部变量。

调用时，有点像类的实例化。

如果类只有一个方法时，可以考虑使用闭包替代。

可以简化程序的复杂度，提高可读性。

```python
# 外层函数
def print_msg():
    msg = "zen of python"

    # 嵌套函数
    def printer():
        print(msg)

    return printer # 注意：这里返回内部函数，而不是调用函数，函数名后面没有括号

# 有点像类的实例化
another = print_msg()
another()  # 调用实例，输出msg
```

## 匿名函数 lambda

## 函数式编程

### map()

### filter()

### reduce