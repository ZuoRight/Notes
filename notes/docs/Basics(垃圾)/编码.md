编码：文本  =》整数数字（码点）

进制转换：非二进制数字  =》二进制数字

二进制：字节 =》比特

1byte=8bit，最大二进制为11111111=十进制255

2byte最大整数可表示655535



计算机诞生美国，所以最初128个整数即可完整表示英文字母的大小写（26*2）+10个数字+字符（标点符号，控制符），即键盘上那些东西，所以1个字节就够了，单字节编码系统即可做到，比如：ASCII（只用7位就够）https://www.ascii-code.com/



后来计算机传入西欧，他们所特有的字符无法完全用ASCII表示，于是做了扩展（表格符号，计算符号，希腊字母，拉丁符号），统称EASCII（8位，依然1个字节就可表示）



但是汉字有成千上万个，即使常用的也有2500个，所以至少需要两个字节来表示，于是中国在ASCII的基础上，制定了GB2312编码（包含6763个汉字），后来又在此基础上创建了GBK（27484个汉字，同时还包含藏文蒙文维吾尔文等少数民族文字），除了中国外，还有其他国家也会存在这样的问题，比如日文，韩文等，每个国家都制定一套自己标准，不可避免的会出现冲突。



于是人们就想着把所有语言统一到一套编码中，当时做这件事的有两个团队，一个叫UCS，一个叫Unicode，当他们发现对方的存在时决定共同搞一套规范，名字就叫Unicode，俗称万国码/统一码。它也是兼容ASCII的。通常用U+xxx形式表示。需要被定义的符合有很多，所以它肯定不是一次性定义完的，比如7.0版本时已收录了10w+符号，那它是咋定义的呢：分区，每个区可以存放2的16次方个字符，被称为一个平面，目前共有17分区/平面。最先被定义的肯定是最常见的那些字符，它们被放在了第一个分区/平面，称作基本平面（缩写为BMP，从U+0000到U+FFFF）剩下的都叫辅助平面（缩写SMP）



Unicode只规定了每个字符对应的码点，而一个码点占用几个字节由Unicode的编码方式UTF规定，也叫字符集，比如UTF-32，规定四个字节表示一个码点，但这出现了一个问题，就是如果文本都是纯英文的话，那么就比直接用ASCII多4倍的存储空间。所以出现了边长型的UTF-8编码，它会根据不同码点大小占用1~6个字节，比如英语通为1个字节，汉字为3个字节，很节省空间。一般在计算机内存中会统一使用Unicode，但在存储和传输的时候都会转换为UTF-8以节省空间和提高性能，比如.html文件一般会声明：

```html
<meta charset="UTF-8"/>
```



由于.py源码文件本身也是文本格式，也会出现非英文的情况，所以如果想保证其被读取时使用UTF-8编码，需要在文件开头以注释的形式加上一些声明（Py3 默认使用UTF-8，而Py2由于比Unicode诞生早，所以默认编码是ASCII）

```python
#!/usr/bin/python
# -*- coding: utf-8 -*-
# 或者
# coding=utf-8
```

1. 告诉类Unix系统这是一个Python可执行程序，Windows系统会忽略这个注释
2. 告诉Python解释器按照UTF-8编码读取源代码



另外还有UTF-16，结合了定长和变长的方式。基本平面的字符占用2个字节，辅助平面占用4个，就是说要么占用2个要么4个字节。其实UTF-16是之前的UCS-2的超集，后来取代了UCS-2，因为UCS-2有个问题就是一个字符如果是4字节的会被当成两个2字节的字符，而UTF-16为此做了一个巧妙的设计（辅助平面的字符被拆成了两个基本平面的字符表示）避免了这个问题。由于JS诞生于（1995年）UCS-2（1990年）和UTF-16（1996年）它们之间，所以最初选用了USC-2编码方式（没有选用UTF-8是因为当时UTF-8还不成熟，而UCS-2在内存方面操作及使用效率更高），不过ES6已经改为默认UTF-16，将不再存在4字节的问题。

## 解释器

参考文章：

<https://www.cnblogs.com/mq0036/p/5014236.html>

<http://www.omegaxyz.com/2018/02/21/cpython/>

### CPython

CPython把Python源码编译成字节码（.pyc），然后再解释这些字节码，执行之。

### PyPy

由Python的一个子集RPython所编写，所以并不是自举。