# 引言

- 早期定义(`1973, Bill Hetz`)：软件测试是对程序能够按预期运行建立起的一种信心。
- 经典定义(`1979, Myers`)：测试是为发现错误而执行程序的过程。
- IEEE定义：使用人工或自动手段来运行或测量软件系统的的过程，以检验软件系统是否满足规定的要求，并找出与预期结果之间的差异。

说白了就是找 Bug，但请不要称之为捉虫...

宗旨：在有限的时间和资源内，尽可能的发现问题，发现至今未发现的问题，尽早的暴露出来，并且协助开发尽快解决。

发现问题，分析问题（分析出问题也就解决了一大半），解决问题

## 测试原则

- 测试对象不止是程序，还有各种文档等
- 统计表明，大多数的 Bug 来自于对需求的错误理解，所以测试要尽早介入，尽可能降低修复成本
- 测试依赖于测试场景
- Bug的分布遵循二八法则，即 Bug 往往会集中在某一模块
- 测试的杀虫剂悖论，同一功能不能总是用同一条 Case 反复验证
- 穷尽测试是不可能的，应设定及时终止的条件
- 测试显示缺陷的存在，但经过软件测试不能证明系统不存在缺陷

## 测试方法/策略

> <https://time.geekbang.org/column/article/11462>

- 传统软件：慢，通常采用金字塔模型，重点在 GUI 测试

![20230721231203](https://image.zuoright.com/20230721231203.png)

- 互联网软件：快，通常采用菱形模型，重点在 API 测试

保证测试质量和测试覆盖率的前提下，有效缩短测试执行时间

![20230721231626](https://image.zuoright.com/20230721231626.png)

## 测试方案

> 通常由测试负责人制定

测试方案一般是对测试计划的进一步细化和明确，是技术层面的文档。

它描述需要测试的特性、测试的方法、测试环境的规划、测试工具的设计及选择、测试用例的设计方法、测试代码的设计方案等。

- 测试目标
- 测试原则
- 被测试项：功能、非功能
- 测试方法/策略：UI测试、接口测试、兼容性测试、安全测试、性能测试
- 测试环境：工具、框架

## 测试计划

> 通常由测试管理者制定

任务分配、时间安排

## 测试规范

包含但不限于以下内容

- 编写测试用例
- 测试用例评审
- Bug管理
- 测试结果/报告

## 测试分类

### 静态测试

### 动态测试

- 白盒测试，又称结构测试，或逻辑驱动测试，常用于单元测试
- 黑盒测试，又称功能测试，或数据驱动测试
- 灰盒测试，常用于集成测试

按阶段划分

- 单元测试 Unit Test
- 集成测试 Integration Tests
- 冒烟测试 是从电路板测试引入的概念。当电路板做好以后，首先会加电测试，如果板子没有冒烟再进行其它测试，否则就必须重新来过。
- 系统测试
- 回归测试
- 验收测试
- 探索性测试
- 随机测试

其中系统测试可以包括

- API测试
- GUI测试
- 兼容性测试
- 本地化测试
- 性能测试 Performance Test
- 安全测试

验收测试通常可以分为

- α版本测试，通常供开发方测试
- β版本测试，通常供测试方测试
- Release版本测试，通常供第三方测试

## 兼容性测试

- 电脑端(PC)
    - Mac
    - Windows
    - Linux
- 移动端：不同机型（热门品牌）、不同分辨率
    - Android
    - iOS
- 浏览器
    - Chrome
    - Safari
    - Edge
    - Firefox
- 不同版本
    - 向上兼容，渐进增强：业务优先，新版本老功能不会受影响，比如做网站，向上兼容，则会更关注内容本身。
    - 向下兼容，优雅降级：新特性优先，新版本老功能可能失效，比如做网站，则会优先考虑那些最高级、最完善的浏览器来设计网站。
- 不同网络环境
- 不同语言
- 不同主题：夜间/日间、背景等
- 分享功能：分享到主流APP
- 其它：标准规范等

兼容性测试比较枯燥，最好采用自动化方式来做，比如移动端

- Appium + Selenium Grid + OpenSTF
- 云测平台：Testin、SauceLab

## 软件测试模型

- V模型
- W模型
- X模型
- H模型

## 自动化测试

自动化本身并不难，难的是产生价值。

- 自动化测试只是一种测试手段，仅能替代重复的手工操作，并不能替代手工测试。
- 自动化的本质是发现变化的东西对不变的东西的影响，即主要用于回归测试，验证新功能是否影响了旧功能。
- 自动化一定是基于业务的，必须要考虑可重用性和维护成本，不要为了自动化而自动化，从而违背测试的宗旨。

自动化不是银弹，而且有很多成本：开发成本，维护成本，与手工测试重复测试造成的无用功损耗。

开发告诉你改了哪里，只测相关的改动，但是线上却出现了问题，出在那些没有改动的地方，所以经验性的减少测试Case是没有依据的，但是又有时间的限制，我们不能Cover所有，所以需要自动化。

自动化依据的是测试用例，测试用例遗漏或者出了问题，自动话也一定是有问题的，所以自动化不能解决所有问题，也不能与手工无缝衔接

自动化主要搞定环境和数据（为满足不同场景需要参照数据，即动态数据）

自己做的云测其实根本用不起来，不现实，除非 Testin 这种云基础，公有云不行，私有云，随插随跑（想到百度之前的架子）

自动化有没有用？有必要做，但为啥做着做着就失败了呢，有成本，有特定环境，试用范围。

更多的只是团队能力的积累和提升，很多测试人员偷偷学自动化然后跳槽，团队可以一起公开搞，提高团队能力。

自动化维护成本很高，而前端是最容易变得东西

质量保证是上层的东西，质量控制是底层的

## 测试左移

- 单元测试
- 研发自测
- 代码评审（Code Review）
- 自动化冒烟测试
- 代码审计

## 测试右移

线上监控

- 线上问题闭环：验证问题-反馈结果-状态更新等
- 更便捷丰富的日志查看，方便定位问题
- 关键指标每日监控
- 生产数据监控
- 业务监控：比如短信邮件等收发

## 精准化测试

- 根绝代码变更自动分析影响范围
- 代码调用链与黑盒测试用例关联
- 代码流程分析与覆盖率统计
- 黑盒测试过程中借助代码流程覆盖数据指导探索式测试
- 利用线上数据推导有效测试用例

## 混沌工程

混沌工程是一种软件工程方法论，旨在通过有意地在系统中引入故障来测试系统的可靠性和稳定性。

这种做法背后的基本原理是通过模拟可能导致系统故障的各种场景（例如硬件故障、网络延迟、系统资源耗尽等），来验证和提高系统在生产环境下的弹性。

1. 定义稳态：确定系统的正常行为（稳态），以便在引入故障时能够衡量系统偏离这种状态的程度。
2. 变量假设：明确系统设计中的假设，例如，某个服务的高可用性或数据库的快速响应。
3. 小规模开始：从小规模和非核心系统开始引入故障，逐步扩大到更大的系统。
4. 故障注入：使用混沌工具（如 Chaos Monkey、Gremlin 等）在系统中引入各种故障（如关闭服务器、制造网络拥堵或断开数据库连接）。
5. 监控和分析：监控系统的响应并分析故障注入对系统稳态的影响。
6. 优化和修复：根据测试结果进行系统调整和修复，增强系统的弹性。
