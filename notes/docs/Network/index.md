# 引言

![20240616204339](https://image.zuoright.com/20240616204339.png)

- P2P（Peer-to-Peer）不区分客户端和服务端，两台主机是对等关系
- C/S（Client/Server）区分为客户端和服务端，客户端是主机上的程序
- B/S（Browser/Server）区分为客户端端和服务端，客户端是浏览器

无论服务端，还是客户端，运行的单位都是进程。

一台机器上部署运行了多个服务，比如同时开启了 SSH 服务和 HTTP 服务等。

一个客户端，同一个时刻可以建立多个到不同服务器的连接，比如同时购物、刷视频、看新闻等。

每个连接使用不同的端口来区分不同的服务和客户，服务端的端口是固定的，客户端是系统内核临时分配的，每个客户端每个连接的临时端口号都是不同的，确保数据不会混淆。

套接字对（四元组）：`(clientaddr:clientport, serveraddr: serverport)`

![20240616205722](https://image.zuoright.com/20240616205722.png)

## Socket

参考：

- <https://time.geekbang.org/column/article/113607>
- <https://mp.weixin.qq.com/s/fq5uyKXXp7HY8Clxf-AAbQ>

Socket 套接字，起初是由加州大学伯克利分校在 UNIX 的 BSD 分支提出的，所以也被叫做伯克利套接字，本身不是协议，只规定了 API，屏蔽了底层协议栈的差别，抽象出来的一层，可以理解为网络插槽。

![20240617175426](https://image.zuoright.com/20240617175426.png)

TCP 套接字通常叫做字节流套接字（SOCK_STREAM），UDP 套接字通常叫做数据报套接字（SOCK_DGRAM）

> 字节流可类比为管道里的水流一样，但传输的是二进制数据，而且是可以双向的。

Socket 本质上就是个代码库，包含 `socket()`、`connect()`、`bind()` 等方法，这就是纯裸的 TCP 实现

![20240616212400](https://image.zuoright.com/20240616212400.png)

首先服务端初始化 socket，执行 bind 函数，将自己的服务能力绑定在一个众所周知的地址和端口上，紧接着，服务器端执行 listen 操作，将原先的 socket 转化为服务端的 socket，服务端最后阻塞在 accept 上等待客户端请求的到来。

服务器端已经准备就绪。客户端开始寻址，即根据 URL 获取服务端的地址和端口。

然后客户端需要先初始化 socket，再执行 connect 向服务器端的地址和端口发起连接请求。即 TCP 三次握手（Three-way Handshake）

然后客户端和服务器端建立连接，就进入了数据传输过程，比如可以进行一次 HTTP 请求，然后需要和服务器端断开连接时，执行 close 函数

## 网络通信

如果想将数据从一台电脑发送到另一台电脑，可以使用 socket 编程，即 tcp 或 udp

但是裸 tcp 会有粘包问题，即无法对字节流进行分词断句

所以需要加一些协议，用于区分消息边界，于是基于 tcp 就衍生出了 rpc 和 http 等各种协议

![20240612172103](https://image.zuoright.com/20240612172103.png)

rpc 本身并不是一个具体的协议，而是一种调用方式，即屏蔽掉一些细节，像调用本地方法一样调用远程方法，于是就出现了各种 rpc 协议，至今没有一个统一标准

> rpc 不一定都是依赖 tcp，也有 依赖 udp 或 http 的

![20240612165318](https://image.zuoright.com/20240612165318.png)

起初在 C/S 架构中，客户端只需访问自家公司的服务端即可，所以使用各自的 rpc 协议就可以

但随着 B/S 浏览器的兴起，需要访问不同公司的服务器，因此需要一个统一的标准协议，不然无法通信，于是诞生了 http

也就是说 rpc 通常用于 C/S 架构，http 通常用于 B/S 架构，不过如今很多公司的服务端要同时支持移动端、PC 端以及 Web 端，所以通常都使用统一的 http 协议，而 rpc 开始退居幕后，主要用于公司内部集群中各个微服务之间的通信

- 服务发现

要向某个服务发起请求，需要先建立连接，也就需要先知道 IP 地址和端口，这个过程即服务发现

在 http 协议中，知道域名后，通过 DNS 服务解析即可获取到 IP，端口默认 80

rpc 协议中会有专门的中间服务保存服务名和IP信息，比如 consul 或 etcd，甚至是 redis，要想访问某个服务就需要先到这些中间服务获取 IP 和端口信息

- 底层连接

主流的 http 1.1 在建立底层 tcp 连接后，会一直保持连接，供之后的请求都复用，

rpc 协议跟 http 类似，也是建立 tcp 长连接进行数据交互，但不同的地方在于，rpc 协议一般还会再建个连接池，大大的提升了网络请求性能

> 很多编程语言的网络库也会给 http 加连接池来提高性能，比如 Go

- 序列化

数字和字符都可以通过编码直接转为二进制，而结构体则需要序列化

http 协议通常使用 json 来序列化结构体数据

rpc 不需要考虑重定向等浏览器行为，可以使用体积更小的序列化协议，不同的 rpc 可以根据自身特点定制化，比如 gRPC 使用 protobuf

因此 rpc 传输内容性能更好，这就是微服务之间采用 rpc 协议的主要原因

不过 http 2.0 改进提升了性能，比很多 rpc 协议还要好，比如 gRPC 底层就使用了 http 2.0

tcp 协议虽然是全双工的，但 http 协议是半双工的，同一时间只能一端给另一端发数据

比如扫码就是客户端请求服务端

- 轮询
- 长轮训

这是由于当时设计时未考虑像网页游戏这样的场景

于是基于 tcp 的全双工协议 websocket 应运而生

使用 websocket 协议需要先发送一个 http 协议，请求头中带上特殊的字段，然后升级为 ws 协议

正因如此，有人会说 websocket 是建立在 http 之上的，其实只是建立连接时用到了 http，升级到 ws 后便与 http 没有任何关系了

![20240612192609](https://image.zuoright.com/20240612192609.png)

websocket 完美继承了 tcp 的全双工能力，又解决了粘包问题，适用于客户端与服务器频繁交互的大部分场景，比如网页或小程序游戏、网页聊天室等

## 网络分层

阿帕网（互联网的前身，大概1970年）使用网络控制协议（Network Control Protocol, NCP）来连接不同的计算机进行通信，1974 年 NCP 的两位开发者发表了以分组、序列化、流量控制、超时和容错等为核心的一种新型网络互联协议，即后来的互联网协议套件(IPS)：TCP/IP，于 1983 年正式取代 NCP。

在 TCP/IP 协议的基础之上，1984 年 ISO 又推出了开放式系统互联模型：OSI(Open System Interconnection)

> 无论 TCP/IP 还是 OSI 都只是参考模型，并不是标准，无论是四层、五层、还是七层，本质都是一样的

OSI 总共分为七层，每一层明确了编号，描述的网络更加完整

- L7 应用层：HTTP、SMTP、FTP、DNS、WebSocket
- L6 表示层，加密解密、转换翻译、压缩解压缩：JPEG、GIF
- L5 会话层，不同机器上的用户之间建立及管理会话：RPC、SQL、NFS
- L4 传输层，屏蔽有无连接的差异，面向进程：TCP、UDP、SPX
- L3 网际层，屏蔽异种网络路由的差异，面向主机：IP、ARP
- L2 数据链路层
- L1 物理层

上三层与软件相关，可以统称为业务层，传输层承上启下，下三层与硬件相关

![20230520220837](http://image.zuoright.com/20230520220837.png)

![网络分层模型](http://image.zuoright.com/网络分层模型.png)

![20210808231312](http://image.zuoright.com/20210808231312.png)

![20230823204412](https://image.zuoright.com/20230823204412.png)

![20220103224646](http://image.zuoright.com/20220103224646.png)

每一种链路层协议都规定了帧能传输的最大数据长度，即最大传输单元（MTU, Maximum Transmission Unit）

![20230518083859](http://image.zuoright.com/20230518083859.png)

以太网MTU一般默认为1500 Bytes，如果来自传输层的报文超过MTU，IP层则需要分段传输给MAC层。所以需要设置一个合适的段长度，称之为最大段长度（MSS, Maximum Segment Size），过大会导致IP分片传输，过小则网络利用率太低。

`MTU = MSS + TCP首部(20B) + IP首部(20B) + 可选部分`
