# 传输层

## 交换

### 电路交换

电路交换主要用于语音传输，性能更高

所有的电话两两相连是不现实的，而是先通过低速线路连接到电话交换局的电话交换机，然后电话交换局通过高速线路连接到长途局，这些线路和交换机设备组成了一个个子网，最后形成电信网，由电话公司负责管理，而电话本身并不属于子网。

![20230514235241](http://image.zuoright.com/20230514235241.png)

早期使用接线员作为人肉交换机，后来改为了自动交换机，但原理都一样，拨号，然后交换机自动选择一条线路，这条线路被称之为虚电路（VC, Virtual Circuit），虚线路建立后，对方电话铃响，开是通话，只要通话不断，则相应线路会被一直占用

![20230519225055](http://image.zuoright.com/20230519225055.png)

### 报文交换

需要存储全部的报文才会转发，比如以前的电报

![20230515000832](http://image.zuoright.com/20230515000832.png)

存储转发（Store and forward）建模自邮政系统，也类似于物流系统，即信件/货物/信息被发送到中间站，查找转发表继续转发到下一站

### 分组交换

也称数据包交换，或封包交换，不需要建立通道，健壮性更好

报文被分割为一个个分组，每个分组都是一个数据包，由首部和数据两部分组成

路由器存储转发时，不需要等待完整的报文，接收方收到所有数据后再排序组装

## 服务

- 面向连接的服务（connection-oriented service）就是按照电话系统建模的
- 面向无连接的服务（conncetionless service）则是按照邮政系统建模的

![20230513144032](http://image.zuoright.com/20230513144032.png)

![20230513144432](http://image.zuoright.com/20230513144432.png)

## Socket

Socket 套接字，由加州大学伯克利分校的研究人员在 20 世纪 80 年代早期提出的，所以也被叫做伯克利套接字，用于屏蔽底层协议栈的差别而抽象出来的一个网络插槽。然后被UNIX 和 Windows 等操作系统接受采用。

TCP 套接字通常叫做字节流套接字（SOCK_STREAM），UDP 套接字通常叫做数据报套接字（SOCK_DGRAM）

> 字节流可类比为管道里的水流一样，但传输的是二进制数据，而且是可以双向的。

Socket 本质上就是个代码库，包含 `socket()`、`connect()`、`bind()` 等方法，这就是纯裸的 TCP 实现

![20240616212400](https://image.zuoright.com/20240616212400.png)

首先服务端初始化 socket，执行 bind 函数，将自己的服务能力绑定在一个众所周知的地址和端口上，紧接着，服务器端执行 listen 操作，将原先的 socket 转化为服务端的 socket，服务端最后阻塞在 accept 上等待客户端请求的到来。

服务器端已经准备就绪。客户端开始寻址，即根据 URL 获取服务端的地址和端口。

然后客户端需要先初始化 socket，再执行 connect 向服务器端的地址和端口发起连接请求。即 TCP 三次握手（Three-way Handshake）

然后客户端和服务器端建立连接，就进入了数据传输过程，比如可以进行一次 HTTP 请求，然后需要和服务器端断开连接时，执行 close 函数

## 传输协议

传输层主要有两种协议：UDP、TCP

UDP跟IP一样，传输形式都是包，它只管转发数据，不需要建立连接，并不关心数据是否被送达，所以也不会关心数据被送达的顺序等等。可以一对多。

而TCP比较复杂，是以字节流(没头没尾)的形式分段且有序传输的，需要建立连接，遇到阻塞数据丢失等会重传。只能一对一。

> 所谓的建立连接，只是逻辑上的概念，本质是指客户端和服务端各自维护一定的数据结构(一种状态机)，来记录和维护这个“连接”的状态。
>
> 如果说前三层协议建立了一座桥，则四层的TCP只是在桥的两端增加了记录审查人员，它只能努力保障自己这一层传输的可靠性，至于下层的桥是否牢固可靠，跟TCP无关。

UDP可以用在环境简单、需要多播，以及应用层自己控制传输的场景：

- DHCP广播获取IP
- VXLAN
- QUIC（Quick UDP Internet Connections，快速 UDP 互联网连接）（由Google 提出）
- 实时游戏
- 很多直播应用，都基于 UDP 实现了自己的视频传输协议，因为基于TCP的直播协议RTMP在延迟较高时卡顿比较严重
- IoT物联网通信协议 Thread（由Google 旗下的 Nest 建立 Thread Group推出）

![20220103112203](http://image.zuoright.com/20220103112203.png)

端口号大小：2Bytes*8bit=16bit，所以取值范围为：1~65535（2^16，0和65536不使用），使用IP+端口号则可以一对一连接。

> UDP头部只有源端口和目的端口，而TCP相对比较复杂

- 源/目标端口号，应用程序会监听端口号，通过端口号来区分收/发程序
- 序号，用于重发与控制顺序，保证可靠通信
- 确认序号，为了确认是否丢包
- 窗口大小，流量控制和阻塞控制
- 校验和，用于校验信息是否在传输中出现损失
- 状态标识位，连接维护

```text
SYN 建立连接
FIN 关闭连接
ACK 响应
PSH 有DATA数据传输
RST 连接重置
```

## TCP三次握手

```text
A：您好，我是 A。
B：您好 A，我是 B。
A：您好 B。
```

![20210808234230](http://image.zuoright.com/20210808234230.png)

握手的目的：

1. 建立连接，保证双方可以互相发送和接收数据（全双工）
2. 互相确认对方数据片段的起始序号，为后续数据传输做准备

完全满足以上两点至少需要三次握手，同时恰好解决了重复链接的问题

> 为了防止冲突，起始序号并不能从1开始，起始序号要随着时间变化，每4微秒+1，每个连接都要有不同的序号。

## TCP四次挥手

```text
A：我完事了。
B：我知道了，我还没完事。
B：我也完事了。
A：我知道了。
```

![20210808234244](http://image.zuoright.com/20210808234244.png)

经过“四次挥手”确保双方都知道且同意对方断开连接，然后移除为对方维护的数据结构和信息，对方之后发送的包也不会接收，直到再次连接。

## Socket 编程

- `server.py`

```python
import socket

def start_server():
    # 创建 socket 对象
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    # 绑定主机和端口
    host = 'localhost'
    port = 12345
    server_socket.bind((host, port))
    
    # 监听连接
    server_socket.listen(5)
    print(f"服务器已启动，监听地址：{host}:{port}")

    while True:
        # 等待客户端连接
        print("等待客户端连接...")
        client_socket, addr = server_socket.accept()  # 三次握手在 accept() 调用过程中完成
        print(f"连接地址: {addr}")

        # 接收数据
        data = client_socket.recv(1024).decode('utf-8')
        print(f"收到数据: {data}")

        # 发送响应
        client_socket.send("Hello, Client".encode('utf-8'))

        # 关闭连接
        client_socket.close()  # 四次挥手在 close() 调用过程中完成
        print("连接关闭")

if __name__ == '__main__':
    start_server()
```

- `client.py`

```python
import socket

def start_client():
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    # 连接服务器
    host = 'localhost'
    port = 12345
    print("尝试连接服务器...")
    client_socket.connect((host, port))  # 三次握手在 connect() 调用过程中完成

    # 发送数据
    message = 'Hello, Server'
    client_socket.send(message.encode('utf-8'))

    # 接收响应
    response = client_socket.recv(1024).decode('utf-8')
    print(f"服务器响应: {response}")

    # 关闭连接
    client_socket.close()  # 四次挥手在 close() 调用过程中完成
    print("连接关闭")

if __name__ == '__main__':
    start_client()
```

- run

先运行 server 端，然后运行 client 端

客户端发送一个连接请求（SYN包）给服务器，使用的是服务器的IP地址和端口号（即 localhost: 12345），然后随机分配一个临时端口号（如 51191）一起发送给服务器，服务器接收到请求后，使用该临时端口号作为目的端口号发送响应数据包（SYN-ACK包），客户端接收到响应后，确认连接（发送ACK包），完成三次握手，建立TCP连接。

服务端端口号是固定的，客户端的端口号是临时的，每个客户端每个连接都使用使用的临时端口号都是不同的，确保数据不会混淆。

```shell
# server端打印
服务器已启动，监听地址：localhost:12345
等待客户端连接...
连接地址: ('127.0.0.1', 51191)
收到数据: Hello, Server
连接关闭

# client端打印
尝试连接服务器...
服务器响应: Hello, Client
连接关闭
```
