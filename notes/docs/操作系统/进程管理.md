# 进程

程序(Program)，通常为二进制文件，一般存储在物理磁盘中

被用户触发执行后会加载到内存中，以进程(Process)的方式运行，并给予一个唯一标识，即PID

操作系统根据触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置

程序之间会互相调用，基本流程为：fork-and-exec，即先从父进程fork出一个相同的临时进程，然后再以exec的方式执行实际要执行的进程，即子进程

当我们登陆并执行bash中执行命令时，其实就是在bash这个父进程(PPID)中运行的子进程，只不过这些命令基本都是运行完就结束了

但也有些进程执行完并不会立刻结束，而是常驻在内存中，这些进程通常都是负责一些系统所提供的功能以服务用户的各项任务，称之为：服务(daemon)，主要分为本地服务和网络服务

> 服务一般会在文件名后加上d，比如：httpd
>
> 网络服务会提供一个端口(port)，供外部客户端请求连接
>
> 查看进程：`ps -l`

Linux默认提供了七个终端（六个命令行界面以及一个图形界面，可以使用Alt+F1/.../7来切换），每个终端可以登录不同用户，每个用户每次登录后获取shell的PID都是不同的，据此可以进行一些个性化设置（`~/.bashrc`），由于CPU每秒可以在不同进程之间快速切换，所以多人同时使用系统时是无感知的

> 如果某个终端因某个进程卡死导致界面不能动，可以切换到另一个终端，用`ps -aux`找出有问题的进程然后kill掉，再切回刚才的终端就又恢复了正常

## init 进程

一个 Linux 操作系统，在系统打开电源，执行 BIOS/boot-loader 之后，就会由 boot-loader 负责加载 Linux 内核

> Linux 内核执行文件一般会放在 /boot 目录下，文件名类似 vmlinuz*

在内核完成了操作系统的各种初始化之后，这个程序需要执行的第一个用户态程就是 init 进程，也叫1号进程，于是系统从内核态切换到用户态，然后创建其他进程。

> 内核代码启动 1 号进程的时候，在没有外面参数指定程序路径的情况下，一般会从几个缺省路径尝试执行 1 号进程的代码

Systemd 是目前最流行的 Linux init 进程（在它之前还有 SysVinit、UpStart 等），无论是哪种 Linux init 进程，它最基本的功能都是创建出 Linux 系统中其他所有的进程，并且管理这些进程。

目前主流的 Linux 发行版都会把/sbin/init 作为符号链接指向 Systemd

```bash
ls -l /sbin/init
"""
lrwxrwxrwx 1 root root 20 Jul 21 19:00 /sbin/init -> /lib/systemd/systemd
"""
```

## 信号

当我们在运行kill命令时，其实就是主动向进程发送了一个信号，可以用`kill -l`查看所有信号的编号和名字，此外还有一些自动的情况，比如Ctrl+c时，当前运行的进程就会收到SIGINT信号然后退出。

![20210826205955](http://image.zuoright.com/20210826205955.png)

```bash
kill pid # 默认发送编号为15的SIGTERM信号
kill -9 <pid>  # 也可以指定，比如这里就代表发送编号为9的SIGKILL信号
```

![20210826212807](http://image.zuoright.com/20210826212807.png)

当我们运行 kill 1 这个命令的时候，希望把 SIGTERM 这个信号发送给 1 号进程，于是调用了kill()这个内核的调用接口（即系统调用），从而进入到了内核函数 sys_kill()，而内核在决定把信号发送给 1 号进程的时候，会调用 sig_task_ignored() 这个函数来做个判断，有以下三种情况：

1. 忽略(Ignore)，即不做任何处理
2. 捕获(Catch)，即进程可以针对某个信号注册相应的handler，用户进程如果不注册，则使用SIG_DFL这个缺省的 handler
3. 缺省(Default)，每个信号都有一个缺省行为，可使用`man 7 signal`查看

有两个特权信号：`SIGKILL` 和 `SIGSTOP`，它们是Linux 为 kernel 和超级用户去删除任意进程所保留的，不能被忽略，也不可以被捕获。比如进程一旦收到SIGKILL信号就要退出。

另外，Linux 内核针对每个 Nnamespace 里的 init 进程，把只有 default handler 的信号都给忽略了。所以容器的 init 进程是永远不能被 SIGKILL 所杀（因为特权信号不能被捕获，进程默认使用default handler），即`kill -9 1`在容器中是不工作的（宿主机也一样），但是在可以被 SIGTERM 杀死（前提是注册了handler）。

## 任务

无论进程还是线程，在 Linux 内核里其实都是用 task_struct{}这个结构来表示的。它其实就是任务（task），也就是 Linux 里基本的调度单位