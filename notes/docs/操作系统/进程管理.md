# 进程管理

程序(Program)，通常为二进制文件，一般存储在物理磁盘中

被用户触发执行后会加载到内存中，以进程(Process)的方式运行，并给予一个唯一标识，即PID

操作系统根据触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置

程序之间会互相调用，基本流程为：fork-and-exec，即先从父进程fork出一个相同的临时进程，然后再以exec的方式执行实际要执行的进程，即子进程

> 查看进程：`ps -l`

当我们登陆并执行bash中执行命令时，其实就是在bash这个父进程(PPID)中运行的子进程，只不过这些命令基本都是运行完就结束了

## 服务

但也有些进程执行完并不会立刻结束，而是常驻在内存中，这些进程通常都是负责一些系统所提供的功能以服务用户的各项任务，称之为：服务(daemon)，主要分为本地服务和网络服务

> 服务一般会在文件名后加上d，比如：httpd
>  
> 网络服务会提供一个端口(port)，供外部客户端请求连接

Linux默认提供了七个终端（六个命令行界面以及一个图形界面，可以使用Alt+F1/.../7来切换），每个终端可以登录不同用户，每个用户每次登录后获取shell的PID都是不同的，据此可以进行一些个性化设置（`~/.bashrc`），由于CPU每秒可以在不同进程之间快速切换，所以多人同时使用系统时是无感知的

> 如果某个终端因某个进程卡死导致界面不能动，可以切换到另一个终端，用`ps -aux`找出有问题的进程然后kill掉，再切回刚才的终端就又恢复了正常

## init 进程

一个 Linux 操作系统，在系统打开电源，执行 BIOS/boot-loader 之后，就会由 boot-loader 负责加载 Linux 内核

> Linux 内核执行文件一般会放在 /boot 目录下，文件名类似 vmlinuz*

在内核完成了操作系统的各种初始化之后，这个程序需要执行的第一个用户态程就是 init 进程，也叫1号进程，于是系统从内核态切换到用户态，然后创建其他进程。

> 内核代码启动 1 号进程的时候，在没有外面参数指定程序路径的情况下，一般会从几个缺省路径尝试执行 1 号进程的代码

Systemd 是目前最流行的 Linux init 进程（在它之前还有 SysVinit、UpStart 等），无论是哪种 Linux init 进程，它最基本的功能都是创建出 Linux 系统中其他所有的进程，并且管理这些进程。

目前主流的 Linux 发行版都会把/sbin/init 作为符号链接指向 Systemd

```bash
ls -l /sbin/init
"""
lrwxrwxrwx 1 root root 20 Jul 21 19:00 /sbin/init -> /lib/systemd/systemd
"""
```

## 信号

当我们在运行kill命令时，其实就是主动向进程发送了一个信号，可以用`kill -l`查看所有信号的编号和名字，此外还有一些自动的情况，比如Ctrl+c时，当前运行的进程就会收到SIGINT信号然后退出。

![20210826205955](http://image.zuoright.com/20210826205955.png)

```bash
kill pid # 默认发送编号为15的SIGTERM信号
kill -9 <pid>  # 也可以指定，比如这里就代表发送编号为9的SIGKILL信号
```

![20210826212807](http://image.zuoright.com/20210826212807.png)

当我们运行 kill 1 这个命令的时候，希望把 SIGTERM 这个信号发送给 1 号进程，于是调用了kill()这个内核的调用接口（即系统调用），从而进入到了内核函数 sys_kill()，而内核在决定把信号发送给 1 号进程的时候，会调用 sig_task_ignored() 这个函数来做个判断，有以下三种情况：

1. 缺省(Default)，每个信号都有一个缺省行为，可使用`man 7 signal`查看
2. 捕获(Catch)，即进程可以针对某个信号注册相应的handler，用户进程如果不注册，则使用SIG_DFL这个缺省的 handler
3. 忽略(Ignore)，即不做任何处理

有两个特权信号：`SIGKILL` 和 `SIGSTOP`，它们是Linux 为 kernel 和超级用户去删除任意进程所保留的，不能被忽略，也不可以被捕获。比如进程一旦收到SIGKILL信号就要退出。

另外，Linux 内核针对每个 Nnamespace 里的 init 进程，把只有 default handler 的信号都给忽略了。所以容器的 init 进程是永远不能被 SIGKILL 所杀（因为特权信号不能被捕获，进程默认使用default handler），即`kill -9 1`在容器中是不工作的（宿主机也一样），但是在可以被 SIGTERM 杀死（前提是注册了handler）。

进程对信号的处理其实就包括两个问题：

1. 进程如何发送信号：发送信号的系统调用是 kill()
2. 进程收到信号后如何处理：signal() 它可以给信号注册 handler

内核中对不同的信号有不同的缺省行为，一般会采用退出（terminate），暂停（stop），忽略（ignore）这三种行为中的一种。

对于 SIGTERM 这个信号来说，它的缺省行为就是进程退出

捕获指的就是我们在代码中为某个信号，调用 signal() 注册自己的 handler。这样进程在运行的时候，一旦接收到信号，就不会再去执行内核中的缺省代码，而是会执行通过 signal() 注册的 handler。

当 Linux 进程收到 SIGTERM 信号并且使进程退出，这时 Linux 内核对处理进程退出的入口点就是 do_exit() 函数，do_exit() 函数中会释放进程的相关资源，比如内存，文件句柄，信号量等等。

在做完这些工作之后，它会调用一个 exit_notify() 函数，用来通知和这个进程相关的父子进程等。

![20210829153533](http://image.zuoright.com/20210829153533.png)

对于容器来说，还要考虑 Pid Namespace 里的其他进程。这里调用的就是 zap_pid_ns_processes() 这个函数，而在这个函数中，如果是处于退出状态的 init 进程，它会向 Namespace 中的其他进程都发送一个 SIGKILL 信号。

SIGKILL 是个特权信号（特权信号是 Linux 为 kernel 和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获）。所以进程收到这个信号后，就立刻退出了，没有机会调用一些释放资源的 handler 之后，再做退出动作。

那么怎么解决停止容器的时候，容器内应用程序被强制杀死的问题呢

解决的方法就是在容器的 init 进程中对收到的信号做个转发，发送到容器中的其他子进程，这样容器中的所有进程在停止时，都会收到 SIGTERM，而不是 SIGKILL 信号了。

## 任务

无论进程还是线程，在 Linux 内核里其实都是用 task_struct{}这个结构来表示的。它其实就是任务（task），也就是 Linux 里基本的调度单位

![20210828204948](http://image.zuoright.com/20210828204948.png)

`ps` 查看状态

运行态(R stat)

- 运行中(即获得了CPU资源)
- 运行队列中

睡眠态(等待队列)

> 进程需要等待某个资源（可以是一个信号量(Semaphore), 或者是磁盘I/O）

- TASK_INTERRUPTIBLE 可中断(S stat)
- TASK_UNINTERRUPTIBLE 不可中断(D stat)

退出态

- EXIT_ZOMBIE 进程退出前的状态（僵尸进程）
- EXIT_DEAD 进程结束退出时的状态

每一个 Linux 进程在退出的时候都会进入一个僵尸状态（EXIT_ZOMBIE）；

僵尸进程如果不清理，就会消耗系统中的进程数资源，最坏的情况是导致新的进程无法启动；

僵尸进程一定需要父进程调用 wait() 或者 waitpid() 系统调用来清理，这也是容器中 init 进程必须具备的一个功能、

> wait() 系统调用是一个阻塞的调用，也就是说，如果没有子进程是僵尸进程的话，这个调用就一直不会返回，那么整个进程就会被阻塞住，而不能去做别的事了  
> waitpid() 如果在调用的时候没有僵尸进程，那么函数就马上返回

## 最大进数

一台 Linux 机器上的进程总数目是有限制的。如果超过这个最大值，那么系统就无法创建出新的进程了

查看最大进程数：`/proc/sys/kernel/pid_max`（4194304kb）

对于 Linux 系统而言，容器就是一组进程的集合。如果容器中的应用创建过多的进程或者出现 bug，就会产生类似 fork bomb 的行为。

> fork bomb 指在计算机中，通过不断建立新进程来消耗系统中的进程资源，它是一种黑客攻击方式。这样，容器中的进程数就会把整个节点的可用进程总数给消耗完。

这样，不但会使同一个节点上的其他容器无法工作，还会让宿主机本身也无法工作。所以对于每个容器来说，我们都需要限制它的最大进程数目，而这个功能由 pids Cgroup 这个子系统来完成。

pids Cgroup 通过 Cgroup 文件系统的方式向用户提供操作接口，在一个容器建立之后，创建容器的服务会在挂载点 /sys/fs/cgroup/pids 下建立一个子目录，就是一个控制组，控制组里最关键的一个文件就是 pids.max。我们可以向这个文件写入数值（即容器中允许的最大进程数目）。