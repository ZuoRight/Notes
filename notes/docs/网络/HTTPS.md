# HTTPS

HTTPS是在HTTP和TCP之间增加了SSL/TLS协议，目的是提高数据传输的安全性。

SSL/TLS最初叫做SSL(Secure Sockets Layer)，是由网景公司发明，经历了v1~v3版本的迭代，然后改名为TLS(Transport Layer Security)继续迭代，目前最常用版本为TLSv1.2。

SSL/TLS主要由一些子协议和密码套件组成。其中密码套件主要基于一些开源的密码学底层库实现，比如最常用的OpenSSL。

数据从客户端安全送达服务端，依然离不开上层的HTTP和下层的TCP，但我们暂且把他们都当作黑盒处理，接下来只探讨保障了安全的SSL/TLS协议，一步步拆解开来。

首先我们需要把明文数据加密，加密主要有两种方式，对称加密和非对称加密。对称加密是指加密和解密使用相同的密钥，效率高，但安全系数较低。而非对称加密在加密时使用一把密钥，解密时使用另一把密钥，安全系数较高，但效率较低。

两者各有优缺点，优先考虑效率，所以我们选择对称加密。

> 对称加密算法主要有：
> 
> - AES：最流行、属于块加密
> - CHACHA20：属于流加密
> 
> 另外还涉及到分组模式：GCM、CCM、Poly1305，此处不做过多详解。

客户端加密完之后得到一个密钥，需要将密钥传输给服务端，但这个传输的过程又将产生不安全的问题，不过由于密钥信息较短，效率问题可以忽略，所以我们选择更安全的非对称加密。

非对称由两把密钥组成，一把称之为私钥，另一把称之为公钥。用私钥加密的数据只能由公钥解密，同理由公钥加密的数据只能用私钥解密。

> 非对称算法主要有：
> 
> - RSA：最著名，既支持密钥交换也支持身份认证
> - ECC：更优，仅支持密钥交换，需要搭配DH、DSA等组成ECDHA、ECDSA实现身份认证功能

私钥必须要要保密，不能泄露，而公钥需要传送给客户端，用于加密对称加密产生的密钥，也就是说客户端在传输对称加密数据之前，需要先请求服务端得到非对称加密的公钥。

公钥不需要考虑加密传输的问题，即被人获取也无所谓，因为只要没有私钥，就无法解密它加密的信息，但这里需要考虑一个信任问题，就是客户端要确保它在跟对的人通信，收到的公钥是真正的服务端发送而来，即公钥从服务端到客户端没有被中间人替换或者篡改过。

通常我们解决信任问题，都需要借助一些可信赖的第三方机构作背书，，网络世界亦是如此，所以我们需要有一个为公钥拥有者身份作认证的机构，于是证书颁发机构就被创立了，简称CA(Certificate Authority)，它会对公钥拥有者做专业认证，认证通过会颁发一个叫做数字证书(digital certificate)的东西，以此来证明公钥来源确实可信。

> 全球最大的七家CA：Comodo、Symantec、Trend Micro、DigiCert、Entrust、GlobalSign、GoDaddy
> 
> 他们一起组成了证书颁发机构理事会(CASC)，有点类似联合国安全理事会的感觉。另外还有一个叫做CA/浏览器论坛的专业组织，主要使命是为浏览器和证书颁发机构提供互联网安全行业标准，通常也称为公钥基础设施，简称PKI。CASC的成员必须遵守CA/浏览器论坛制定的标准，目前最新标准为X.509 v3。

作为服务端/申请者，如果想让自己的公钥被客户端所信任，需要将公钥以及一些必要信息等制作成一个CSR(Certificate Signing Request 证书签发请求)文件，通过可信网络提交给CA审核。

> [CSR在线生成工具](https://myssl.com/csr_create.html)

[![](http://image.iswbm.com/20200724124502.png)](https://iswbm.com/72.html)

多说一句，审核并不一定是要提交给上面提到的那几个最大的CA，因为除了这些之外，还有一些大大小小的中介CA，他们会组成一条条信任链，通过信任链的层层认证，最终也会被信任。不过机构越权威，安全等级也就越高，但同时也需要付出更多的费用，是的，申请数字证书是要花钱的（不过也有免费的），而且还不便宜，因为这背后需要很多安全和法律成本，并不是随便一个机构就能搞定的事情。

> CA按安全等级从低到高可分为：
> 
> - DV：只验证申请域名的所有权
> - OV：需对申请者/组织的身份做验证
> - EV：需经过法律和审计的严格核查
>
> CA按保护域名的数量分为：
> 
> - 单域名版：只保护一个域名
> - 多域名版：保护多个域名
> - 通配符版：保护主域名下同一级的所有子域名

CA审核通过后，会按照X.509标准的格式，将所有的必要信息通过哈希/散列函数压缩成一串固定长度的哈希值，称之为信息摘要。这是一个不可逆过程，如果信息被篡改，则哈希值会变，以此保障信息的完整性。

> 摘要算法主要有：
> - MD5
> - SHA-1
> - SHA-2(SHA224、SHA256、SHA384)
> 
> 需要避免两段不同的信息被转变成同一串哈希值，目前SHA-2系列算法更优

然后会通过CA私钥把这些信息和信息摘要一起进行加密，因为CA私钥由CA保管，所以没有私钥的人无法实现这一过程，所以称之为数字签名，至此就生成了一个可信赖的数字证书。

最后，CA将数字证书颁发给申请者，服务端会将其部署到服务器中，在收到客户端请求后将数字证书返回，客户端收到数字证书后，会对数字证书进行验证。

如下图，当我们通过Chrome浏览器访问github.com时，在地址栏域名左边会显示一个可点击的小锁图标，点击后显示链接是安全的，也就是说其证书是可信的。

![20201025232930](http://image.zuoright.com/20201025232930.png)

那么客户端是如何判断这个证书就是可信的呢，继续往下看，点击“证书”，可以看到证书的一些基本信息。

![20201025233957](http://image.zuoright.com/20201025233957.png)

可以看到github.com的颁发者和有效日期，然后把菜单切到“证书路径”tab下，这就是我们前文提到的信任链，通过这个层级结构，就可以知道github.com的颁发者是由DigiCert这个CA认证的，也就是我们前文提到的全球最大CA之一，那么这些顶级的CA机构是由谁认证呢，答案是他们自己给自己认证，当然前提是因为这些顶级机构有足够的实力和信誉我们才选择相信他，就像各个国家的中央机构，你只能选择相信，不然整个社会体制就无法正常运转下去，言归正传，这些顶级CA会给自己签发一个数字证书，通常被称为根证书，这些根证书会被预置在我们的操作系列以及浏览器中，系统会定期检查他们是否已被吊销，尽可能保持最新可信状态。

> 所以不要轻易安装盗版操作系统，因为如果从根儿上就已经不安全了，那么整个信任链也就没有安全可言。

![20201025233805](http://image.zuoright.com/20201025233805.png)

有了这些根证书，我们就能获取到根证书的公钥，就可以用其去解密下级CA的数字证书，因为下级的这些证书都是上级CA的私钥加密的。通过公钥将数字证书解密后，可以获取到数字证书的详细信息以及信息摘要，如下图所示，我们还需要验证这个证书的信息是否有被篡改过，即通过前文提到的摘要算法将这些信息压缩成一段信息摘要，然后将我们自己生成的信息摘要与解密出来的信息摘要做对比，如果一致，则说明信息没有被篡改过，也就说明我们获取到的服务端公钥是可信的，于是，就可以用它来加密对称加密的密钥了。

![20201026000900](http://image.zuoright.com/20201026000900.png)


参考文章：
https://draveness.me/whys-the-design-https-latency/
https://time.geekbang.org/column/article/12996 总流程 趣谈网络协议（那两张图）
https://github.com/youngwind/blog/issues/108 主要流程 github

https://iswbm.com/72.html 概念
https://time.geekbang.org/column/article/108643 透视HTTP协议

- 单向认证：客户端对服务端做认证
- 双向认证：客户端和服务端互相认证
