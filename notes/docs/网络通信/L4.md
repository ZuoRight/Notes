# 传输层

## 服务

![20230513144032](http://image.zuoright.com/20230513144032.png)

面向无连接的服务（conncetionless service）则是按照邮政系统建模的

面向连接的服务（connection-oriented service）就是按照电话系统建模的

![20230513144432](http://image.zuoright.com/20230513144432.png)

## 传输协议

传输层主要有两种协议：UDP、TCP

UDP跟IP一样，传输形式都是包，它只管转发数据，不需要建立连接，并不关心数据是否被送达，所以也不会关心数据被送达的顺序等等。可以一对多。

而TCP比较复杂，是以字节流(没头没尾)的形式分段且有序传输的，需要建立连接，遇到阻塞数据丢失等会重传。只能一对一。

> 所谓的建立连接，只是逻辑上的概念，本质是指客户端和服务端各自维护一定的数据结构(一种状态机)，来记录和维护这个“连接”的状态。
>
> 如果说前三层协议建立了一座桥，则四层的TCP只是在桥的两端增加了记录审查人员，它只能努力保障自己这一层传输的可靠性，至于下层的桥是否牢固可靠，跟TCP无关。

UDP可以用在环境简单、需要多播，以及应用层自己控制传输的场景：

- DHCP广播获取IP
- VXLAN
- QUIC（Quick UDP Internet Connections，快速 UDP 互联网连接）（由Google 提出）
- 实时游戏
- 很多直播应用，都基于 UDP 实现了自己的视频传输协议，因为基于TCP的直播协议RTMP在延迟较高时卡顿比较严重
- IoT物联网通信协议 Thread（由Google 旗下的 Nest 建立 Thread Group推出）

![20220103112203](http://image.zuoright.com/20220103112203.png)

端口号大小：2Bytes*8bit=16bit，所以取值范围为：1~65535（2^16，0和65536不使用），使用IP+端口号则可以一对一连接。

> UDP头部只有源端口和目的端口，而TCP相对比较复杂

- 源/目标端口号，应用程序会监听端口号，通过端口号来区分收/发程序
- 序号，用于重发与控制顺序，保证可靠通信
- 确认序号，为了确认是否丢包
- 窗口大小，流量控制和阻塞控制
- 校验和，用于校验信息是否在传输中出现损失
- 状态标识位，连接维护

![20210808234116](http://image.zuoright.com/20210808234116.png)

## TCP三次握手

```text
A：您好，我是 A。
B：您好 A，我是 B。
A：您好 B。
```

![20210808234230](http://image.zuoright.com/20210808234230.png)

握手的目的：

1. 建立连接，保证双方可以互相发送和接收数据（全双工）
2. 互相确认对方数据片段的起始序号，为后续数据传输做准备

完全满足以上两点至少需要三次握手，同时恰好解决了重复链接的问题

> 为了防止冲突，起始序号并不能从1开始，起始序号要随着时间变化，每4微秒+1，每个连接都要有不同的序号。

## TCP四次挥手

```text
A：我完事了。
B：我知道了，我还没完事。
B：我也完事了。
A：我知道了。
```

![20210808234244](http://image.zuoright.com/20210808234244.png)

经过“四次挥手”确保双方都知道且同意对方断开连接，然后移除为对方维护的数据结构和信息，对方之后发送的包也不会接收，直到再次连接。
