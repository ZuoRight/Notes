# 其它

## 事务 transaction

> <https://www.liaoxuefeng.com/wiki/1177760294764384/1179611198786848>

所谓的事务，就是把多条语句作为一个整体进行操作，这些操作要么全部成功，要么全部失败，是一个不可分割的集合。

事务具有 ACID 4 个特性：

> AID 是实现 C 这个目标的手段

- Atomicity 原子性，将所有SQL作为原子工作单元执行，要么全都执行，要么全不执行；
- Consistency 一致性，事务完成后，所有数据的状态都是一致的，即 A 账户只要减去了100，B 账户则必定加上了 100；
- Isolation 隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；
- Durability 持久性，即事务完成后，对数据库数据的修改被持久化存储，不会再因为任何原因而导致其修改的内容被撤销或丢失。

单条 SQL 语句，其实也是作为一个事务被执行的，属于数据库系统默认的行为，这种事务被称为隐式事务

而通常我们所说的事务是显式事务

```sql
BEGIN;  -- 开启事务，或者 start transaction
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- user1 的余额 -100
UPDATE accounts SET balance = balance + 100 WHERE id = 2;  -- user2 的余额 +100
COMMIT;  -- 提交事务，失败会回滚

-- 可以主动让事务失败回滚
ROLLBACK
```

有些客户端连接框架会默认连接成功后先执行一个 `set autocommit=0` 的命令，则不再需要 `begin` 显示启动事务，但这样会导致事务不再自动 commit，遇到长连接，就会一直处于同一个长事务中。

要避免使用长事务，除了占用锁资源，产生的回滚日志会占用大量存储空间。

```sql
-- 查找持续时间超过 60s 的事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

每条记录在更新的时候都会同时记录一条回滚操作，假设一个值从 1 被按顺序改成了 2、3、4，就会有类似下面的回滚日志记录

![20241017230926](https://image.zuoright.com/20241017230926.png)

即同一条记录在系统中可以存在多个版本，也就是数据库的多版本并发控制（MVCC），可以将值从 4 依次回滚到 1。

当没有事务再需要用到这些回滚日志时，回滚日志才会被删除。

## 隔离级别

当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了「隔离级别」的概念。

![20241017220024](https://image.zuoright.com/20241017220024.png)

SQL 标准定义了 4 种隔离级别，不同隔离级别下 V1,2,3 读到的值是不一样的

```text
读未提交 read uncommitted
事务 B 还没有提交时，变更结果就可以被事务 A 读到，所以 V1=V2=V3=2

读提交 read committed
事务 B 提交后，变更结果才可以被事务 A 读到，所以 V1=2, V2=V3=2

可重复读 repeatable read
事务在执行期间（即提交前）所看到的数据，前后总是一致的，所以 V1=V2=1, V3=2
另外，对其他事务也是不可见的。
适用场景：比如计算上个月余额和当前余额的差值，是否与本月的账单明细一致，这个过程中若不希望用户的新交易影响校对结果，就需要使用可重复读隔离级别。

串行化 serializable
读或写同一行记录时，会加读锁或写锁。当出现冲突时，后访问的事务必须等前一个事务执行完成，才能继续执行。
事务 B 将值从 1 修改到 2 时，会加写锁，作为后执行的事务，需要等待事务 A 提交后才可以继续执行。所以 V1=V2=1, V3=2
```

从视图的角度来理解不同隔离级别

```text
读未提交，直接返回记录上的最新值，没有视图的概念
读提交，SQL 语句开始执行时创建视图
可重复读，事务启动时会创建视图，整个事务存在期间都用这个视图
串行化，使用加锁的方式避免并行访问
```

Oracle 默认的隔离级别是「读提交」，InnoDB 默认的隔离级别是「可重复读」，所以跨数据库迁移时一定要保证隔离级别一致

```sql
-- 查看当前事务隔离级别
SHOW VARIABLES LIKE 'transaction_isolation';
SHOW VARIABLES LIKE 'tx_isolation';  -- v8.0+
-- 查看全局事务隔离级别
SHOW GLOBAL VARIABLES LIKE 'tx_isolation';

-- 设置当前会话隔离级别
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
-- 设置全局隔离级别
SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

不同隔离级别会产生的问题

![20211103154025](http://image.zuoright.com/20211103154025.png)

- 脏读 dirty read，一个事务会读到另一个事务未提交的更新，如果另一个事务回滚，那么当前事务读到的数据就是脏数据。
- 不可重复读 non-repeatable read，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。
- 幻读 phantom read，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。

## 索引 key

- 普通索引：普通索引只是提升数据检索的速度，并不对字段的唯一性进行约束
- 唯一索引：唯一索引相当于给普通索引加了一个约束，可以为NULL，目的是保证字段的正确性，比如身份证号等
- 主键索引

把表中某列的值存储到某种数据结构中，就叫索引

> 最常用的数据结构为：B-Tree

优点

- 提高数据检索效率，降低数据库IO成本
- 通过索引对数据进行排序，降低CPU消耗

缺点

- 占用空间
- 降低了表更新的速度
- 建立最优索引需要花时间研究

适合建立索引的字段：主键，外键，频繁作为查找或排序的字段

> 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高，像性别这种列有索引反而会降低效率，这种情况下大数据中会使用分组的概念

## 性能优化

I/O 是 DBMS 最容易出现瓶颈的地方，可以说数据库操作中有大量的时间都花在了 I/O 上。

慢 SQL 优化，指的是对那些在执行过程中花费较长时间的 SQL 查询进行优化，以提高其执行速度和整体性能

慢 SQL 查询的常见原因

- 缺少索引：查询涉及的表没有适当的索引，导致全表扫描。
- 不合适的索引使用：索引使用不当或者复合索引未能被正确利用。
- 不合理的查询设计：查询语句本身设计不当，如使用了大量的嵌套子查询、未优化的 JOIN 等。
- 数据量过大：查询涉及的数据量过大，没有进行分页或分区。
- 服务器资源不足：数据库服务器的 CPU、内存或磁盘 I/O 资源不足。
- 锁竞争：并发查询之间发生锁竞争，导致查询等待时间增加。

比如对索引字段做函数操作，或有隐式类型转换涉及函数操作，或有隐式字符编码转换，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能，导致全索引扫描。

因此用 `explain + SQL 语句` 分析一下，是一个很好的习惯，它可以模拟优化器执行 SQL 查询语句。

- 尽量只查询所需要的列
- 当你知道只有 1 条记录的时候，就可以使用LIMIT 1来进行约束
